import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as n,c,b as l,d as i,a,e,r}from"./app.759ff6f5.js";const d={},u=e(`<h3 id="菜鸟教程" tabindex="-1"><a class="header-anchor" href="#菜鸟教程" aria-hidden="true">#</a> 菜鸟教程</h3><ul><li><p>网址</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://www.runoob.com/docker/centos-docker-install.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h3 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h3>`,3),s=l("li",null,[l("p",null,"官方安装脚本自动安装"),l("div",{class:"language-text line-numbers-mode","data-ext":"text"},[l("pre",{class:"language-text"},[l("code",null,`curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
`)]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"})])])],-1),m={href:"https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors%EF%BC%8C%E7%99%BB%E9%99%86%E5%90%8E%EF%BC%8C%E5%B7%A6%E4%BE%A7%E8%8F%9C%E5%8D%95%E9%80%89%E4%B8%AD%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E5%9C%B0%E5%9D%80%E4%BA%86%EF%BC%9A",target:"_blank",rel:"noopener noreferrer"},p=e(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://628s02d9.mirror.aliyuncs.com
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{&quot;registry-mirrors&quot;:[&quot;https://628s02d9.mirror.aliyuncs.com/&quot;]}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>重新启动服务</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>systemctl restart docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul>`,2),k=e(`<li><p>设置开机启动</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>systemctl enable docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>启动</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>systemctl start docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>查看状态</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>systemctl status docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>`,3),g=e(`<h3 id="docker自带教程" tabindex="-1"><a class="header-anchor" href="#docker自带教程" aria-hidden="true">#</a> docker自带教程</h3><ul><li><p>命令</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker [OPTIONS] --help
eg:docker --help
eg:docker ps --help
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>根据镜像生成后台启动容器</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -d IAMGE [COMMAND]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>eg:
runoob@runoob:~$ docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;
2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="docker中的核心概念" tabindex="-1"><a class="header-anchor" href="#docker中的核心概念" aria-hidden="true">#</a> docker中的核心概念</h3><ul><li>镜像：类似java中的类，他是生成可运行的容器的标准。镜像为联合文件系统(Union File System)，是一组文件，是分层结构，每层是一个基本的镜像文件。 <ul><li>eg: <ul><li>tomcat:8.0 <ul><li>他内部未集成jdk，不可直接运行java的项目，默认的start参数为<code>catalina.sh run</code>(在未执行命令和参数的前提下默认执行该命令和参数)(tomcat的startup.sh和shutdown.sh内部也使用的是catalina.sh命令)</li></ul></li><li>tomcat:9-jdk8 <ul><li>继承了jdk8的tomcat9，可以直接运行jar包</li></ul></li><li>hello-world <ul><li>docker的测试镜像</li></ul></li><li>ubuntu:15.10 <ul><li>默认的启动参数为<code>/bin/bash</code></li></ul></li></ul></li></ul></li><li>容器：类似java中的对象，他是由镜像创建而成，包含代码、运行时环境、系统工具、系统库和设置运行的容器，直接运行的对象，每个镜像生成的容器都有一个默认的启动命令，容器的命令都是基于自己容器内部的文件，如：tomcat 执行<code>start</code>启动后默认执行<code>catalina.sh run</code> 运行webapps中的项目；ubuntu执行<code>start</code>启动后默认执行<code>/bin/bash</code> 进入容器的内部(需要指定-it，否则容器会闪退)。也可以在创建容器时指定一个启动命令，之后<code>start</code>该容器则会执行该自定义参数。如：ubuntu执行<code>start</code>启动后设置执行<code>/bin/echo hello</code> 打印hello(需要指定-i打印到控制台，否则打印到日志文件)。创建后的容器将会一直存在，一个镜像可以生成多个相同的容器。大部分docker的容器基本都是基于linux制作而成 <ul><li>状态： <ul><li>“created”，表示已创建；</li><li>“restarting”，表示重启中；</li><li>“running”，表示运行中； <ul><li>正在运行的容器可执行 docker exec -it CONTAINER /bin/bash 进入容器的内部操作容器中的文件</li></ul></li><li>“removing”，表示迁移中；</li><li>“paused”，表示暂停状态；</li><li>“exited”，表示停止等等。</li></ul></li></ul></li><li>仓库：存储镜像的地方 <ul><li>分类： <ul><li>中央仓库: docker hub docker官方存储docker镜像的服务器</li><li>阿里云镜像</li><li>本地服务器</li></ul></li></ul></li></ul><h3 id="docker-的网络设置" tabindex="-1"><a class="header-anchor" href="#docker-的网络设置" aria-hidden="true">#</a> docker 的网络设置</h3><ul><li>docker中容器通信的三种方式 <ul><li>容器的ip地址</li><li>宿主机的ip:宿主机映射到容器的端口</li><li>容器名(需要使用自定义的网桥)</li></ul></li></ul><h3 id="docker-命令" tabindex="-1"><a class="header-anchor" href="#docker-命令" aria-hidden="true">#</a> docker 命令</h3><ul><li><p>docker info</p><ul><li>Display system-wide information</li><li>Usage: docker info [OPTIONS]</li><li>Options: <ul><li>-f, --format string Format the output using the given Go template</li></ul></li></ul></li><li><p>docker run</p><ul><li>解释：docker run命令为多个docker命令组合而来的一个综合命令，其执行过程分以下几步：第一步：在本地库中查询是否存在该IMAGE，若存在执行第二步。若不存在，则执行search命令在docker hub中查询是否存在该IMAGE，若存在，pull该IMAGE到本地库，执行第二步。若不存在，给出错误提示，命令执行结束；第二步：执行create命令根据本地库的该IMAGIN生成CONTIANER；第三步：执行start命令运行该CONTIANER</li><li>Run a command in a new container</li><li>Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</li><li>Options: <ul><li>-d, --detach Run container in background and print container ID</li><li>-i, --interactive Keep STDIN open even if not attached</li><li>指示 docker 要在容器上打开一个标准的输入接口</li><li>-t, --tty Allocate a pseudo-TTY</li><li>为容器分配一个伪终端</li><li>-p, --publish list Publish a container&#39;s port(s) to the host</li><li>​ --name string Assign a name to the container</li><li>​ --rm Automatically remove the container when it exits</li></ul></li><li>eg: <ul><li><code>docker run --name ubuntu ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code><ul><li>基于ubnuntu:15.10镜像生成容器ubuntu，并且该容器用于执行 <code>/bin/echo</code> 命令(该命令也是存在ubuntu容器中的命令)，并且该命令的参数为 <code>&quot;Hello world&quot;</code>(默认ubuntu容器执行<code>/bin/bash</code>命令)</li></ul></li><li><code>docker run -it -p 9090:8080 --name=tomcat8 tomcat:8.0</code><ul><li>基于tomcat:8.0镜像生成容器，该容器名为tomcat8，该容器的端口8080映射到宿主机的端口9090，本次的启动方式为打开一个标准的输入接口，并且打开分配一个伪终端，并且默认tomcat容器用于执行 <code>catalina.sh</code> 命令(该命令也是存在容器中的命令)(tomcat容器基于linux制作)，并且该命令的参数为 <code>run</code>(在未执行命令和参数的前提下默认执行该命令和参数)(tomcat的startup.sh和shutdown.sh内部也使用的是catalina.sh命令)(此时的9090不需要宿主机防火墙开启次端口的访问)</li></ul></li></ul></li></ul></li><li><p>docker search</p><ul><li>Search the Docker Hub for images</li><li>Usage: docker search [OPTIONS] TERM</li><li>Options:</li><li>eg: <ul><li><code>docker search hello-world</code><ul><li>在docker hub中检索关键字包括hello-world 的镜像，该镜像为docker的官方测试镜像</li></ul></li><li><code>docker search tomcat</code><ul><li>在docker hub中检索关键字包括tomcat的镜像</li></ul></li></ul></li></ul></li><li><p>docker pull</p><ul><li><p>Pull an image or a repository from a registry</p></li><li><p>sage: docker pull [OPTIONS] NAME[:TAG|@DIGEST]</p></li><li><p>Options:</p></li><li><p>eg:</p><ul><li><code>eg:docker pull hello-world</code><ul><li>从docker hub中拉取hello-world镜像，若未指定镜像的版本即为最新版(latest)</li></ul></li><li><code>eg:docker pull ubuntu:15.10</code><ul><li>从docker hub中拉取ubuntu镜像，版本为15.10</li></ul></li></ul></li></ul></li><li><p>docker images</p><ul><li>List images</li><li>Usage: docker images [OPTIONS] [REPOSITORY[:TAG]]</li><li>Options: <ul><li>-a, --all Show all images (default hides intermediate images) <ul><li>-a显示包括中间镜像在内的所有镜像，中间层镜像是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错</li></ul></li><li>-f, --filter filter Filter output based on conditions provided</li><li>-q, --quiet Only show image IDs</li></ul></li><li>eg: <ul><li><code>docker images</code><ul><li>显示所有顶层镜像(顶层镜像为我们直接使用到的镜像，中间层镜像我们可能使用不到，但他们是顶层镜像)</li></ul></li><li><code>docker images -qa</code><ul><li>显示所有镜像的id(可用于删除所有镜像)</li></ul></li></ul></li></ul></li><li><p>docker create</p><ul><li><p>Create a new container</p></li><li><p>Usage: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</p></li><li><p>Options:</p><ul><li>-i, --interactive Keep STDIN open even if not attached <ul><li>指示 docker 要在容器上打开一个标准的输入接口</li></ul></li><li>-t, --tty Allocate a pseudo-TTY <ul><li>为容器分配一个伪终端</li></ul></li><li>-p, --publish list Publish a container&#39;s port(s) to the host</li><li>-e, --env list Set environment variables</li><li>-v, --volume list Bind mount a volume</li><li>​ --name string Assign a name to the container</li><li>​ --network network Connect a container to a network</li></ul></li><li><p>eg:</p><ul><li><p><code>docker create --name ubuntu ubuntu:15.10 /bin/sh -c &quot;while true;do echo hello world;sleep 1; done&quot;</code></p><ul><li>创建循环输出hello world的容器</li></ul></li><li><p><code>docker create -p 9090:8080 --name tomcat9jdk8 tomcat:9-jdk8</code></p><ul><li>基于tomcat:9-jdk8镜像生成容器，该容器名为tomcat9jdk8 ，该容器的端口8080映射到宿主机的端口9090，本次的启动方式为打开一个标准的输入接口，并且打开分配一个伪终端，并且默认tomcat容器用于执行 <code>catalina.sh</code> 命令(该命令也是存在容器中的命令)(tomcat容器基于linux制作)，并且该命令的参数为 <code>run</code>(在未执行命令和参数的前提下默认执行该命令和参数)(tomcat的startup.sh和shutdown.sh内部也使用的是catalina.sh命令)(此时的9090不需要宿主机防火墙开启次端口的访问)</li></ul></li><li><p><code>docker create -p 8080:8080 -v /usr/local/dockervolume/tomcat/webapps:/usr/local/tomcat/webapps --name tomcat9jdk8 tomcat:9-jdk8</code></p><ul><li>基于tomcat:9-jdk8镜像生成容器，并创建数据卷(目录挂载)，宿主机中目录的内容与容器中的目录的内容一致，其中一方的改动将影响另一方</li></ul></li><li><p><code>docker create --network mybridge -v /usr/local/dockervolume/tomcat/webapps:/usr/local/tomcat/webapps --name tomcat9jdk8 tomcat:9-jdk8</code></p><ul><li>基于tomcat:9-jdk8镜像生成容器，并创建数据卷(目录挂载)，并连接自定义的网络(自定义的网络可以实现使用容器名实现容器中间的通信)(默认为连接docker0网络，该网络无法实现使用容器名实现容器直接的通信)</li></ul></li><li><p><code>docker create --name mysql \\ -p 3306:3306 \\ -v /usr/local/dockervolume/mysql/conf:/etc/mysql/conf.d \\ -v /usr/local/dockervolume/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123 \\ mysql:5.7</code></p><ul><li>MySQL(5.7.19)的默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。</li><li>在容器中运行<code>mysql -uroot -p DATABASE &lt; ***.sql</code>将数据库的数据写入容器</li></ul></li><li><p><code>docker create --name mysql \\ --network mybridge \\ -v /usr/local/dockervolume/mysql/conf:/etc/mysql/conf.d \\ -v /usr/local/dockervolume/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123 \\ mysql:5.7</code></p><ul><li>容器的通信方式为自定义网络，连接到mybridge网络</li><li>在容器中运行<code>mysql -uroot -p DATABASE &lt; ***.sql</code>将数据库的数据写入容器</li></ul></li><li><p><code>docker create --name nginx \\ -p 80:80 \\ -v /usr/local/dockervolume/nginx/nginx.conf:/etc/nginx/nginx.conf \\ nginx</code></p><ul><li><p>/etc/nginx/nginx.conf 为nginx的默认配置文件</p></li><li><p>/etc/nginx/conf.d 为nginx的配置文件目录，该目录下的配置文件可以覆盖默认配置文件</p></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>      upstream myweb{
          server tomcat:8080 weight=5;  
          server tomcat2:8080;
      }
  
      server {
          listen       80;
          server_name  43.139.179.52;
  
          location / {
              #root   /usr/share/nginx/html;
              #index  index.html index.htm;
      
              proxy_pass http://myweb;
          }
      }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>docker create --name nginx \\ --network mybridge \\ -v /usr/local/dockervolume/nginx/nginx.conf:/etc/nginx/nginx.conf \\ nginx</code></p><ul><li>容器的通信方式为自定义网络，连接到mybridge网络</li><li>/etc/nginx/nginx.conf 为nginx的默认配置文件</li><li>/etc/nginx/conf.d 为nginx的配置文件目录，该目录下的配置文件可以覆盖默认配置文件</li></ul></li></ul></li></ul></li><li><p>docker ps</p><ul><li>List containers</li><li>Usage: docker ps [OPTIONS]</li><li>Options: <ul><li>-a, --all Show all containers (default shows just running)</li><li>-f, --filter filter Filter output based on conditions provided</li><li>-q, --quiet Only display container IDs</li></ul></li><li>eg： <ul><li><code>docker ps</code><ul><li>显示运行的容器</li></ul></li><li><code>docker ps -a</code><ul><li>显示所有的容器</li></ul></li><li><code>docker pa -aq</code><ul><li>显示所有的容器的id(可用于删除所有容器)</li></ul></li></ul></li></ul></li><li><p>docker container(该命令是在docker ps基础上后增加的，更加全面，部分命令功能同docker ps)</p><ul><li>Manage containers</li><li>Usage: docker container COMMAND</li><li>Commands: <ul><li>ls List containers</li><li>port List port mappings or a specific mapping for the container</li></ul></li></ul></li><li><p>docker start</p><ul><li>Start one or more stopped containers</li><li>Usage: docker start [OPTIONS] CONTAINER [CONTAINER...]</li><li>Options: <ul><li>-i, --interactive Attach container&#39;s STDIN <ul><li>指示 docker 要在容器上打开一个标准的输入接口</li></ul></li></ul></li><li>eg: <ul><li><code>docker start -i tomcat8</code><ul><li>交互界面运行tomcat8容器</li></ul></li><li><code>docekr start tomcat8</code><ul><li>运行tomcat8容器</li></ul></li></ul></li></ul></li><li><p>docker stop</p><ul><li>Stop one or more running container</li><li>Usage: docker stop [OPTIONS] CONTAINER [CONTAINER...]</li><li>Options:</li></ul></li><li><p>docker exec</p><ul><li>Run a command in a running container</li><li>Usage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</li><li>Options: <ul><li>-d, --detach Detached mode: run command in the background</li><li>-i, --interactive Keep STDIN open even if not attached <ul><li>指示 docker 要在容器上打开一个标准的输入接口</li></ul></li><li>-t, --tty Allocate a pseudo-TTY <ul><li>为容器分配一个伪终端</li></ul></li></ul></li><li>eg: <ul><li><code>docker exec -it tomcat8 /bin/bash</code><ul><li>对tomcat8执行bash命令，该命令进入tomcat8容器内部，并将-i和-t连接起来，使得在-t的伪终端输入的命令可以传入容器中执行(/bin/bash可简化为bash)</li></ul></li></ul></li></ul></li><li><p>docker logs</p><ul><li>Fetch the logs of a container</li><li>Usage: docker logs [OPTIONS] CONTAINER</li></ul></li><li><p>docker rm</p><ul><li>Remove one or more containers</li><li>Usage: docker rm [OPTIONS] CONTAINER [CONTAINER...]</li><li>Options: <ul><li>-f, --force Force the removal of a running container (uses SIGKILL)</li></ul></li><li>eg: <ul><li><code>docker rm -f $(docker images -aq)</code><ul><li>删除所有镜像，即使在运行的容器</li></ul></li></ul></li></ul></li><li><p>docker mri</p><ul><li>Remove one or more images</li><li>Usage: docker rmi [OPTIONS] IMAGE [IMAGE...]</li><li>Options: <ul><li>-f, --force Force removal of the image</li></ul></li><li>eg: <ul><li><code>docker rmi -f $(docker ps -aq)</code><ul><li>删除所有的容器，即使在运行的容器</li></ul></li></ul></li></ul></li><li><p>docker cp</p><ul><li>Copy files/folders between a container and the local filesystem</li><li>Usage: <ul><li>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|</li><li>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</li></ul></li><li>Options:</li><li>eg： <ul><li><code>docker cp /usr/local/myweb/servletSum.war tomcat8:/usr/local/tomcat/webapps</code><ul><li>将宿主机中的文件复制到tomcat8容器的指定路径</li></ul></li><li><code>docker cp tomcat8:/usr/local/tomcat/webapps/servletSum.war /usr/local/myweb</code><ul><li>将tomcat8容器中的文件复制到宿主机的指定路径</li></ul></li></ul></li></ul></li><li><p>docker inspect</p><ul><li>Return low-level information on Docker objects</li><li>Usage: docker inspect [OPTIONS] NAME|ID [NAME|ID...]</li><li>eg: <ul><li><code>docker inspect tomcat9jdk8</code><ul><li>用于查看Mounts中的数据卷</li></ul></li></ul></li></ul></li><li><p>docker volume ls</p><ul><li>List volumes</li><li>Usage: docker volume ls [OPTIONS]</li><li>eg: <ul><li><code>docker volume ls</code><ul><li>用于查看docker所有的数据卷</li></ul></li></ul></li></ul></li><li><p>docker network</p><ul><li>Manage networks</li><li>Usage: docker network COMMAND</li><li>Commands: <ul><li>connect Connect a container to a network</li><li>create Create a network</li><li>disconnect Disconnect a container from a network</li><li>inspect Display detailed information on one or more networks</li><li>ls List networks</li><li>rm Remove one or more networks</li></ul></li><li>eg: <ul><li>docker network create -d bridge mybridge <ul><li>创建一个名为mybridge的bridge网络(在未指定种类的情况下默认为bridge)</li></ul></li><li>docker network ls <ul><li>查看已存在的网络(DRIVER为网络的种类，有bridge、host、null三种)</li></ul></li><li>docker network connect mybridge tomcat9jdk8 <ul><li>将tomcat9jdk8容器与mybridge网络间接在一起</li></ul></li><li>docker network inspect mybridge <ul><li>查看mybridge网络的详细信息，&quot;Containers&quot;查看加入该网络的容器</li></ul></li><li>docker network rm mybridge <ul><li>删除mybridge网络</li></ul></li></ul></li></ul></li><li><p>docker export</p><ul><li>Export a container&#39;s filesystem as a tar archive</li><li>Usage: docker export [OPTIONS] CONTAINER</li><li>eg: <ul><li><code>docker export 7691a814370e &gt; ubuntu.tar</code><ul><li>把容器id为7691a814370e 的容器打包为ubuntu.tar文件到当前路径</li></ul></li></ul></li></ul></li><li><p>docker import</p><ul><li>Import the contents from a tarball to create a filesystem image</li><li>Usage: docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</li><li>eg: <ul><li><code>cat ubuntu.tar | docker import - test/ubuntu:v1.0</code><ul><li>把当前路径ubuntu.tar解析为名为test/ubuntu:v1.0的docker镜像导入</li></ul></li></ul></li></ul></li></ul>`,8);function h(v,b){const o=r("ExternalLinkIcon");return n(),c("div",null,[u,l("ul",null,[s,l("li",null,[l("p",null,[i("设置阿里云镜像(阿里云镜像获取地址："),l("a",m,[i("https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors，登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了："),a(o)]),i(")")]),p]),k]),g])}const f=t(d,[["render",h],["__file","docker.html.vue"]]);export{f as default};
