import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as e,e as a}from"./app.759ff6f5.js";const u={},r=a('<h3 id="消息的可靠性" tabindex="-1"><a class="header-anchor" href="#消息的可靠性" aria-hidden="true">#</a> 消息的可靠性</h3><p><img src="https://markdown-1308523627.cos.ap-chengdu.myqcloud.com/typora/20230330184622.png" alt="image.png"> 其中的每一步都可能导致消息丢失，常见的丢失原因包括：</p><ul><li>发送时丢失：解决方式为生产者确认机制 <ul><li>生产者发送的消息未送达 exchange，到达 publisher-confirm 回调函数（配置在具体的消息发送中）</li><li>消息到达 exchange 后未到达 queue， 到达 publisher-return 回调函数（所有消息配置在统一的配置类中）</li></ul></li><li>MQ 宕机，queue 将消息丢失：解决方式为 mq 持久化 <ul><li>交换机持久化 <ul><li>SpringAMQP 默认是持久化的，RabbitMQ 默认不是持久化的</li></ul></li><li>队列持久化 <ul><li>SpringAMQP 默认是持久化的，RabbitMQ 默认不是持久化的</li></ul></li><li>消息持久化 <ul><li>SpringAMQP 和 RabbitMQ 默认都是持久化的</li></ul></li></ul></li><li>consumer 接收到消息后未消费就宕机：解决方式为失败重试机制 <ul><li>none 消费者获得消息后，mq 则删除队列中的消息</li><li>auto 模式类似事务机制，出现异常时返回 nack，消息回滚到队列；没有异常，返回 ack，消息删除 <ul><li>当发生异常时，在消息在队列和消费者中无限循环</li><li>retry 模式，发生异常时，消费者在本地尝试若干次后返回 ack。 <ul><li>配置异常消息的交换机和队列，消费者在本地尝试若干次后消息进入该队列。</li></ul></li></ul></li><li>manual：自己根据业务情况，判断什么时候该返回 ack</li></ul></li></ul><h3 id="延迟消息" tabindex="-1"><a class="header-anchor" href="#延迟消息" aria-hidden="true">#</a> 延迟消息</h3><ul><li><p>实现的两种方式</p><ul><li>使用死信交换机 <ul><li>发送消息到一个没有消费者的队列，该队列设置过期时间，并且绑定一个死信交换机。当过期时将消息发送至死信交换机路由到死信队列</li><li>设置消费者监听死信队列，处理消息</li></ul></li><li>使用 rabbitmq 自带的延迟插件 <ul><li>将信息投递到延迟交换机，延迟交换机延迟后自动投递到队列，消费者监听该队列。插件的延迟交换机 x-delayed-message 是三种基本交换机之外的另一种特殊交换机，可以将消息存储在内存中，当时间结束则投递给队列</li></ul></li></ul></li><li><p>哪些消息会进入死信交换机</p><ul><li>消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的 requeue 参数设置为 false</li><li>消息是一个过期消息，超时无人消费（可以实现延迟消息）</li><li>要投递的队列消息满了，无法投递</li></ul></li></ul><h3 id="消息堆积" tabindex="-1"><a class="header-anchor" href="#消息堆积" aria-hidden="true">#</a> 消息堆积</h3><ul><li>解决消息堆积有两种思路： <ul><li>增加更多消费者，提高消费速度。也就是我们之前说的 work queue 模式</li><li>扩大队列容积，提高堆积上限 <ul><li>使用惰性队列 <ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul></li></ul></li></ul></li></ul>',7),t=[r];function c(n,_){return i(),e("div",null,t)}const d=l(u,[["render",c],["__file","day05 RabbitMQ消息的可靠性、延迟消息、消息堆积.html.vue"]]);export{d as default};
