import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as e,e as u}from"./app.759ff6f5.js";const s={},d=u('<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><ul><li><p>Redis（全称：Remote Dictionary Server，即远程字典服务器）是一种开源的、高性能的非关系型（NoSQL）内存数据存储系统，也被称为数据结构服务器。Redis 支持多种数据结构，包括字符串（String）、哈希表（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set）等，可以用于缓存、消息队列、实时统计分析、排行榜、计数器等各种场景。</p></li><li><p>Redis 的特点包括：</p></li><li><p>内存存储：Redis 将数据存储在内存中，读写速度非常快。同时，Redis 还提供了数据持久化的机制，可以将内存中的数据保存到磁盘上，以保证数据的安全性和可靠性。</p></li><li><p>多种数据结构：Redis 支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等，这些数据结构在不同的场景下都有各自的优势和应用。</p></li><li><p>多种应用场景：由于 Redis 的高性能、丰富的数据结构和灵活的应用方式，它可以应用于缓存、消息队列、实时统计分析、排行榜、计数器等各种场景。</p></li><li><p>支持分布式：Redis 提供了分布式锁、分布式集群等机制，可以方便地实现高可用、高可靠的分布式系统。</p></li><li><p>总的来说，Redis 是一种高性能、可扩展、多功能的数据存储系统，被广泛应用于各种互联网应用和企业系统中。</p></li></ul><h3 id="特征" tabindex="-1"><a class="header-anchor" href="#特征" aria-hidden="true">#</a> 特征</h3><ul><li>数据间没有必然的关联关系</li><li>内部采用单线程机制进行工作</li><li>高性能。官方提供测试数据，50 个并发执行 100000 个请求,读的速度是 110000 次/s,写的速度是 81000 次/s。</li><li>多数据类型支持 <ul><li>字符串类型 string</li><li>列表类型 list</li><li>散列类型 hash</li><li>集合类型 set</li><li>有序集合类型 sorted_set</li></ul></li><li>持久化支持。可以进行数据灾难恢复</li></ul><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><ul><li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等</li><li>任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的 session 分离</li><li>消息队列</li><li>分布式锁</li></ul><h2 id="数据类型及使用" tabindex="-1"><a class="header-anchor" href="#数据类型及使用" aria-hidden="true">#</a> 数据类型及使用</h2><ul><li>5 中常用的数据类型 <ul><li>string String</li><li>hash HashMap</li><li>list LinkedList</li><li>set HashSet</li><li>sorted_set TreeSet</li></ul></li></ul><h3 id="key-的通用操作" tabindex="-1"><a class="header-anchor" href="#key-的通用操作" aria-hidden="true">#</a> key 的通用操作</h3><ul><li>基本操作 <ul><li>删除指定 key <ul><li>del key</li></ul></li><li>获取 key 是否存在 <ul><li>exists key</li></ul></li><li>获取 key 的类型 <ul><li>type key</li></ul></li></ul></li><li>时效性操作 <ul><li>为指定 key 设置有效期 <ul><li>expire key seconds</li><li>pexpire key milliseconds</li><li>expireat key timestamp</li><li>pexpireat key milliseconds-timestamp</li></ul></li><li>获取 key 的有效时间 <ul><li>ttl key(获取的为秒，若为永久有效返回-1，已过期返回-2)</li><li>pttl key(获取的为毫秒)</li></ul></li><li>切换 key 从时效性转换为永久性 <ul><li>persist key</li></ul></li></ul></li><li>查询符合条件的 key <ul><li>keys pattern(pattern 为通配符，*表示任意个数任意字符，?表示一个任意字符，<code>[]</code>表示其中的一个字符)</li></ul></li><li>其他操作 <ul><li>为 key 改名 <ul><li>rename key newkey(若新的名称已存在，使用 newkey 的老 key 将会被使用 newkey 的新 key 代替)</li><li>renamenx key newkey(若新的名称不存在才可更改)</li></ul></li><li>对所 key 排序<code>[逆序]</code>(只可排序 list、set、zset 返回的结果为排序的结果，并不会影响原列表) <ul><li>sort key <code>[desc]</code></li></ul></li><li>其他 key 通用操作 <ul><li>help @generic</li></ul></li></ul></li><li>db 的操作 <ul><li>切换数据库(redis 一共有 0~15 个库) <ul><li>select index</li></ul></li></ul></li><li>其他操作 <ul><li>quit 退出客户端</li><li>ping 测试客户端和服务端的通信(正常返回 pong)</li><li>echo message 日志输出 message</li></ul></li><li>数据移动到指定库 <ul><li>move key db</li></ul></li><li>数据清除 <ul><li>dbsize 查看当前库的大小</li><li>flushdb 清除当前库的所有数据</li><li>flushall 清除所有库的所有数据</li></ul></li></ul><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> string</h3><ul><li>添加/修改数据(返回值为 ok) <ul><li>set key value</li></ul></li><li>获取数据 <ul><li>get key</li></ul></li><li>删除数据(返回值为 0 或 1) <ul><li>del key</li></ul></li><li>添加/修改多个数据(返回值为 ok)：对于多数据操作而言，一次性操作的数据过少，指令传输过程消耗的时间将增加。一次性操作的数据过多，redis 的单线程机制会使指令执行过程会容易造成阻塞。 <ul><li>mset key1 valuel key2 value2</li></ul></li><li>获取多个数据(返回值为数组) <ul><li>mget key1 key2</li></ul></li><li>获取字符串长度 <ul><li>strlen key</li></ul></li><li>追加信息到原始信息后部(返回值为添加后的长度) <ul><li>append key value</li></ul></li><li>设置数值数据增加指定范围的值：执行的过程为，将 String 转换为 int，增加 increment，再返回 <ul><li>incr key</li><li>incrby key increment</li><li>incrbyfloat key increment</li></ul></li><li>设置数值数据减少指定范围的值 <ul><li>decr key</li><li>decrby key increment</li></ul></li><li>设置数据具有指定的生命周期 <ul><li>setex key seconds value</li><li>psetex key milliseconds value</li></ul></li><li>数据库中的热点数据 key 的命名惯例方式 <ul><li>方式 1：属性值 <ul><li>表名：主键名：主键值：字段名</li><li><code>eg1: student:id:101:name noby</code></li><li><code>eg2: student:id:101:age 20</code></li></ul></li><li>方式 2：json <ul><li>表名：主键名：主键值</li><li><code>eg1: student:id:101 {name:noby,age:20}</code></li></ul></li></ul></li></ul><h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> hash</h3><ul><li>添加/修改数据 <ul><li>hset key field value</li></ul></li><li>获取数据 <ul><li>hget key field</li><li>hgetall key</li></ul></li><li>删除数据 <ul><li>hdel key field1</li></ul></li><li>添加/修改多个数据 <ul><li>hmset key field1 valuel field2 value2 ..</li></ul></li><li>获取多个数据 <ul><li>hmget key field1 field2 ..</li></ul></li><li>获取哈希表中字段的数量 <ul><li>hlen key</li></ul></li><li>获取哈希表中是否存在指定的字段 <ul><li>hexists key field</li></ul></li><li>获取哈希表中所有的字段名或字段值 <ul><li>hkeys key</li><li>hvals key</li></ul></li><li>设置指定字段的数值数据增加指定范围的值 <ul><li>hincrby key field increment</li><li>hincrbyfloat key field increment</li></ul></li><li>不存在时添加数据，存在时不执行操作 <ul><li>hsetnx key field value</li></ul></li><li>注意事项：</li><li>hash 类型下的 value 只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）</li><li>每个 hash 可以存储 2 32 - 1 个键值对</li><li>hash 类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但 hash 设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将 hash 作为对象列表使用</li><li>hgetall 操作可以获取全部属性，如果内部 field 过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ul><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> list</h3><ul><li>添加/修改数据(l 代表 left，r 代表 right) <ul><li>lpush key valuel <code>[value2]</code>...</li><li>rpush key valuel <code>[value2]</code>...</li></ul></li><li>获取数据(l 代表 lish，-1 索引可代表最后一个，-2 代表倒数第二个) <ul><li>lrange key start stop</li><li>lindex key index</li><li>llen key</li></ul></li><li>获取并移除数据(当 push 和 pop 都为同一方向时为队列结构，不同为栈结构) <ul><li>1pop key</li><li>rpop key</li></ul></li><li>规定时间内获取并移除数据 <ul><li>blpop key1 <code>[key2]</code>... timeout</li><li>brpop key1 <code>[key2]</code>... timeout</li></ul></li><li>移除指定数据(count 表示数量，value 表示左边起第一个该 value 值为起始的位置) <ul><li>lrem key count value</li></ul></li><li>注意</li><li>list 中保存的数据都是 string 类型的，数据总容量是有限的，最多 2 32 - 1 个元素 (4294967295)。</li><li>list 具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list 可以对数据进行分页操作，通常第一页的信息来自于 list，第 2 页及更多的信息通过数据库的形式加载</li></ul><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> set</h3><ul><li>添加数据 <ul><li>sadd key member1 <code>[member2]</code>...</li></ul></li><li>获取全部数据 <ul><li>smembers key</li></ul></li><li>删除数据 <ul><li>srem key memberl <code>[member2]</code>...</li></ul></li><li>获取集合数据总量 <ul><li>scard key</li></ul></li><li>判断集合中是否包含指定数据 <ul><li>sismember key member</li></ul></li><li>随机获取集合中指定数量的数据 <ul><li>srandmember key <code>[count]</code></li></ul></li><li>随机获取集合中指定数量的数据，并将该数据移出集合 <ul><li>spop key <code>[count]</code></li></ul></li><li>求两个集合的交、并、差集 <ul><li>sinter key1 <code>[key2]</code></li><li>sunion key1 <code>[key2]</code></li><li>sdiff key1 <code>[key2]</code></li></ul></li><li>求两个集合的交、并、差集并存储到指定集合中 <ul><li>sinterstore destination key1 <code>[key2]</code></li><li>sunionstore destination key1 <code>[key2]</code></li><li>sdiffstore destination keyl <code>[key2]</code></li></ul></li><li>将指定数据从原始集合中移动到目标集合中 <ul><li>smove source destination member</li></ul></li><li>注意</li><li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li><li>set 虽然与 hash 的存储结构相同，但是无法启用 hash 中存储值的空间</li></ul><h3 id="sorted-set" tabindex="-1"><a class="header-anchor" href="#sorted-set" aria-hidden="true">#</a> sorted_set</h3><ul><li>添加数据 <ul><li>zadd key scorel memberl <code>[score2 member2]</code></li></ul></li><li>获取全部数据 <ul><li>zrange key start stop <code>[WITHSCORES]</code></li><li>zrevrange key start stop <code>[WITHSCORES]</code></li></ul></li><li>删除数据 <ul><li>zrem key member <code>[member ..]</code></li></ul></li><li>按条件获取数据 <ul><li>zrangebyscore key min max <code>[WITHSCORES]</code> <code>[LIMIT]</code></li><li>zrevrangebyscore key max min <code>[WITHSCORES]</code></li></ul></li><li>条件删除数据 <ul><li>zremrangebyrank key start stop</li><li>zremrangebyscore key min max</li></ul></li><li>获取集合数据总量 <ul><li>zcard key</li><li>zcount key min max</li></ul></li><li>集合交、并操作 <ul><li>zinterstore destination numkeys key <code>[key ..]</code></li><li>zunionstore destination numkeys key <code>[key ..]</code></li></ul></li><li>获取数据对应的索引（排名） <ul><li>zrank key member</li><li>zrevrank key member</li></ul></li><li>score 值获取与修改 <ul><li>zscore key member</li><li>zincrby key increment member</li></ul></li><li>注意</li><li>min 与 max 用于限定搜索查询的条件</li><li>start 与 stop 用于限定查询范围，作用于索引，表示开始和结束索引</li><li>offset 与 count 用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li><li>score 保存的数据存储空间是 64 位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score 保存的数据也可以是一个双精度的 double 值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</li><li>sorted_set 底层存储还是基于 set 结构的，因此数据不能重复，如果重复添加相同的数据，score 值将被反复覆盖，保留最后一次修改的结果</li></ul>',20),t=[d];function a(r,o){return i(),e("div",null,t)}const y=l(s,[["render",a],["__file","day01 Redis的数据类型及基本使用.html.vue"]]);export{y as default};
