import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as n,c as d,b as l,d as i,a as t,e,r as c}from"./app.759ff6f5.js";const a={},s=e('<h3 id="目录结构" tabindex="-1"><a class="header-anchor" href="#目录结构" aria-hidden="true">#</a> 目录结构</h3><table><thead><tr><th>文件夹</th><th>英文全称</th><th>文件夹作用</th></tr></thead><tbody><tr><td><strong>/bin -&gt; /usr/bin</strong></td><td>Binaries</td><td>存放系统常用命令的目录，所有用户都可以执行。这些命令和系统启动无关，单人维护模式下还能够被操作的指令</td></tr><tr><td>/boot</td><td>Boot</td><td>存放系统开机启动加载程序的Linux核心文件。</td></tr><tr><td>/dev</td><td>Devices</td><td>所有的装置和接口设备的存放位置</td></tr><tr><td><strong>/etc</strong></td><td>Editable Text Configuration Chest</td><td>存放配置文件的目录</td></tr><tr><td><strong>/home</strong></td><td>Home</td><td>一般用户的根目录(root用户的根目录位于 root)</td></tr><tr><td>/lib -&gt; /usr/lib</td><td>Library</td><td>存放系统程序运行所需的共享库</td></tr><tr><td>/lost+found</td><td>Lost And Found</td><td>存放一些系统出错的检查结果</td></tr><tr><td>/media</td><td>Media</td><td>挂载目录。 挂载媒体设备，如软盘和光盘</td></tr><tr><td>/mnt</td><td>Mount</td><td>挂载目录。临时文件系统的安装点，默认挂载光驱和软驱的目录</td></tr><tr><td><strong>/opt</strong></td><td>Optional Application Software Packages</td><td>可选应用软件包，第三方安装的软件保存位置，存放软件安装包。(以前的linux放在 /usr/local，如今也有这样的习惯)</td></tr><tr><td>/proc</td><td>Processes</td><td>虚拟文件系统，数据保存在内存中，存放当前进程信息</td></tr><tr><td><strong>/root</strong></td><td>Root</td><td>存放root用户的相关文件,root用户的家目录。宿主目录，超级用户</td></tr><tr><td><strong>/run</strong></td><td>Run</td><td>里面的东西是系统运行时需要的, 不能随便删除. 但是重启的时候应该抛弃. 下次系统运行时重新生成</td></tr><tr><td>/sbin -&gt; /usr/sbin</td><td>Superuser Binaries</td><td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令，有些命令可以允许普通用户查看。</td></tr><tr><td>/srv</td><td>Server</td><td>服务数据目录</td></tr><tr><td>/sys</td><td>System</td><td>文件系统</td></tr><tr><td><strong>/tmp</strong></td><td>Temporary</td><td>存放临时文件</td></tr><tr><td><strong>/usr</strong></td><td>Unix Software Resources</td><td>Unix软件目录，存放所有命令、库、手册页等</td></tr><tr><td><strong>/var</strong></td><td>Variable</td><td>是储存各种变化的文件，比如log等等</td></tr><tr><td><strong>/usr/local</strong></td><td>Local</td><td>安装第三方软件的安装目录，一般是通过编译源码的方式安装的程序。</td></tr><tr><td><strong>/usr/local/src</strong></td><td>Source</td><td>安装第三方软件的源码目录，一般是通过编译源码的方式安装的程序。</td></tr><tr><td>/misc</td><td>Miscellaneous Device</td><td>挂载目录。 挂载NFS服务</td></tr></tbody></table><table><thead><tr><th>文件</th><th>文件的作用</th></tr></thead><tbody><tr><td>/etc/profile</td><td>系统整体的配置文件（jdk的配置文件配置在此）</td></tr><tr><td>~/.bash_profile</td><td>某个用户的配置文件</td></tr><tr><td>/etc/rc.d/rc.local</td><td>设置开机自动执行脚本(需将该文件需改为可执行文件)</td></tr><tr><td>~/.bashrc</td><td>该用户bash的配置文件</td></tr><tr><td>/etc/bashrc</td><td>bash的配置文件</td></tr><tr><td>/etc/passwd</td><td>账户信息</td></tr><tr><td>/etc/shadow</td><td>账户的密码</td></tr><tr><td>/etc/group</td><td>群组信息</td></tr><tr><td>/etc/gshadow</td><td>群组的密码</td></tr></tbody></table><h3 id="常用快捷键" tabindex="-1"><a class="header-anchor" href="#常用快捷键" aria-hidden="true">#</a> 常用快捷键</h3><ul><li>[Tab]： <ul><li>在指令后面表示，指令补全提示 <ul><li>eg:<code>dat [Tab]</code><ul><li>当dat开头的命令仅仅为一个时，直接补全命令</li></ul></li><li>eg: <code>d [Tab][Tab]</code><ul><li>当d开头的命令不仅仅为一个时，一个[Tab]键将不能补全，使用两次[Tab]键将可列出所有符合规则的指令</li></ul></li></ul></li><li>在文件后面表示，文件补全提示 <ul><li>eg:<code>cd 目录部分文件名[Tab]</code><ul><li>当符合要求的文件名仅仅为一个时，直接补全文件名</li></ul></li></ul></li><li>在选项后面表示，选项补全，该功能需要安装bash-completion命令补全增强软件包 <ul><li>eg:<code>date --[Tab][Tab]</code><ul><li>什么都不输入的情况下，按[Tab]两次列出所有选项</li></ul></li></ul></li></ul></li><li>[ctrl]+[c]: <ul><li>强制退出当前程序</li></ul></li><li>[ctrl]+[d]: <ul><li>退出当前程序</li></ul></li><li>[shift]+[pagedown]/[pageup] <ul><li>命令行上下翻页</li></ul></li><li>[ctrl]+[pagedown]/[pageup] <ul><li>上下行移动</li></ul></li><li>[Alt]+[Backspace] <ul><li>命令行环境下，删除光标之前的当前词</li></ul></li><li>[Ctrl]+[U] <ul><li>从光标处删除文本直到行首</li></ul></li><li>[Ctrl]+[L] <ul><li>清屏</li></ul></li><li>[Ctrl]+[R] <ul><li>按字符串寻找历史命令(继续Ctrl R 切换匹配项)</li></ul></li><li>[Ctrl]+[Z] <ul><li>把当前进程放到后台（之后可用&#39;&#39;fg&#39;&#39;命令回到前台）</li></ul></li><li>[Ctrl]+[w] <ul><li>删除词</li></ul></li></ul><h3 id="linux中的文件" tabindex="-1"><a class="header-anchor" href="#linux中的文件" aria-hidden="true">#</a> linux中的文件</h3><ul><li>linux中的文件没有强制要求扩展名，但通常会以一定的规则指定扩展名，使他人了解文件的可能用途 <ul><li>.sh <ul><li>脚本或批处理文件（sh表示shell）</li></ul></li><li>.tar .tar.gz .zip .tgz 表示gunzip和tar生成的压缩文件</li><li>.html 表示网页文件</li></ul></li></ul><h3 id="命令帮助" tabindex="-1"><a class="header-anchor" href="#命令帮助" aria-hidden="true">#</a> 命令帮助</h3><ul><li>指令的 --help求助说明 <ul><li>eg: <code>date --help</code></li></ul></li><li>man page <ul><li>eg: <code>man date</code></li></ul></li><li>info page <ul><li>eg: <code>info date</code></li></ul></li></ul><h3 id="命令的组成" tabindex="-1"><a class="header-anchor" href="#命令的组成" aria-hidden="true">#</a> 命令的组成</h3><ul><li><code>command [-options] parameter1 parameter2 ...</code><ul><li>command为指令的名称，例如变换工作目录的指令为cd等等；一行指令中第一个输入的部分绝对是指令(command)或可执行文件（例如批次脚本，script)</li><li>中刮号[]并不存在于实际的指令中，而加入选项设定时，通常选项前会带 - 号，（有时也会带+号）例如 -h；有时候会使用选项的完整全名，则选项前带有 -- 符号，例如 --help;</li><li>parameter1、parameter2 为依附在选项后面的参数，作为command的参数；</li><li>指令，选项，参数之间空格符来分隔，不论空几格shll都视为一格；</li><li>按下[Enter]按键后，该指令就立即执行。[Enter]按键代表着一行指令的开始启动。</li><li>指令太长的时候不方便观看时，可以使用反斜杠 \\ +[Enter] ，使指令连续到下一行。</li><li>其他： <ul><li>在Linux系统中，英文大小写字母是不一样的。举例来说，cd与CD并不同。</li></ul></li></ul></li><li>linux下达指令时，会有两种主要的情况： <ul><li>输入指令后直接显示结果，然后回到命令提示字符环境； <ul><li>eg:<code>date</code></li></ul></li><li>输入指令后进入到该软件功能的环境，直到输入结束指令(eg:quit,exit)才退出软件回到命令提示字符的环境。 <ul><li>eg:<code>bc</code></li></ul></li></ul></li><li>bash中，当命令太长时，可使用 /（转义字符）将enter转义，从而达到换行的目的</li><li>多条命令同时书写可用 ; 隔开</li></ul><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h3><ul><li><p>reboot: 重启</p></li><li><p>sync</p><ul><li>更新i-node 表，并将缓冲文件写到硬盘中</li></ul></li><li><p>ifconfig: 配置和显示Linux系统网卡的网络参数，查看 IP(centos 最小版，没有网络工具包)</p></li><li><p>ip addr: 查看 IP(centos 最小版可用)</p></li><li><p>ping: 用来测试主机之间网络的连通性</p><ul><li>eg: <code>ping 192.168.1.110</code></li></ul></li><li><p>netstat: 查看Linux中网络系统状态信息</p><ul><li>eg: <code>netstat -anp | grep 3306</code><ul><li>查看3306端口的占用情况</li></ul></li></ul></li><li><p>curl: 利用URL规则在命令行下工作的文件传输工具，查看网络是否能够访问某域名</p><ul><li>eg: <code>curl www.baidu.com</code></li></ul></li><li><p>firewall-cmd: 防火墙设置</p><ul><li><p>eg: <code>firewall-cmd --zone=public --query-port=8080/tcp</code></p><ul><li>查看端口</li></ul></li><li><p>eg: <code>firewall-cmd --zone=public --add-port=8080/tcp --permanent</code></p><ul><li>添加开放端口，–permanent永久生效，没有此参数重启后失效</li></ul></li><li><p>eg: <code>firewall-cmd --reload</code></p><ul><li>重新载入--重启防火墙</li></ul></li><li><p>eg: <code>firewall-cmd --zone=public --remove-port=6379/tcp --permanent</code></p><ul><li>删除端口</li></ul></li></ul></li><li><p>clear: 终端清屏</p></li><li><p>ls(list directory contents): 目录查看</p><ul><li>颜色：蓝色为文件夹，白色为一般文件，绿色为可执行文件</li><li>选项 <ul><li>-a: 全部文件</li><li>-d: 仅列出文件夹</li><li>-l: 长数据串列出详细属性</li><li>-i: 查看inode</li><li>--time: <ul><li>mtime(modification time) <ul><li>文件内容数据修改时间</li></ul></li><li>ctime(status time) <ul><li>文件状态改变的时间</li></ul></li><li>atime(access time) <ul><li>文件内容被读取的时间</li></ul></li></ul></li></ul></li><li>eg: <code>ls nobydir</code><ul><li>查看nobydir目录的下的文件列表</li></ul></li><li>eg: <code>ls -l</code><ul><li>查看当前目录的下的目录的详细文件列表(很多发行版可简写为 ll)</li></ul></li><li>eg: <code>ls -al</code><ul><li>查看当前目录的下的隐藏目录的详细信息</li></ul></li><li>eg: <code>ll /etc/man_db.conf;ll --time=atime /etc/man_db.conf;ll --time=ctime /etc/man_db.conf</code><ul><li>查看该文件对应的内容数据修改时间(不加参数的默认状态)，状态数据时间，内容读取时间；多个命令之间可用 ; 号隔开</li></ul></li></ul></li><li><p>pwd(print work directory): 显示路径</p><ul><li>eg: <code>pwd </code><ul><li>显示当前位置路径</li></ul></li><li>eg: <code>pwd -P</code><ul><li>显示当前位置路径的真实路径（非链接路径）</li></ul></li></ul></li><li><p>cd(change directory): 目录切换</p><ul><li>eg: <code>cd /</code><ul><li>退回到根目录</li></ul></li><li>eg: <code>cd ../</code><ul><li>退回到上级目录(所有的目录都存在 .. 和 . 代表上一层目录和本层目录)</li></ul></li><li>eg: <code>cd ../..</code><ul><li>退回到上两层目录</li></ul></li><li>eg: <code>cd /usr/local/src</code><ul><li>表示进入根目录下的 /usr/local/src 路径</li></ul></li><li>eg: <code>cd local/src</code><ul><li>表示进入当前目录下的 local/src 路径</li></ul></li><li>eg: <code>cd ~(或cd)</code><ul><li>进入本用户的家目录(root 用户的家目录为 /root，非 root 用户的根目录为 /home/用户名)</li></ul></li><li>eg: <code>cd ~用户名</code><ul><li>进入指定用户的家目录</li></ul></li><li>eg: <code>cd -</code><ul><li>退回上次记录径路</li></ul></li></ul></li><li><p>mkdir(make directory): 建立目录</p><ul><li>eg: <code>mkdir testdir</code><ul><li>当前路径下建立目录</li><li>mkdir a &amp;&amp; cd $_</li></ul></li><li>eg: <code>mkdir testdir &amp;&amp; cd $_</code><ul><li>当前路径下建立目录，并进入该目录，$_ 表示在此之前执行的命令或者脚本的最后一个参数</li></ul></li><li>eg: <code>mkdir -p testdir1/testdir2</code><ul><li>建立多层目录</li></ul></li><li>eg: <code>mkdir -m 755 testnobydir</code><ul><li>建立权限为 755 的目录(不指定默认为755)</li></ul></li></ul></li><li><p>rmdir(remove directory): 删除空目录</p><ul><li>eg: <code>rmdir testdir</code><ul><li>删除当前路径下的testdir空目录</li></ul></li><li>eg: <code>rmdir -p testdir1/testdir2</code><ul><li>删除多层空目录</li></ul></li></ul></li><li><p>rm(remove): 删除命令</p><ul><li>eg: <code>rm -r testdir</code><ul><li>删除目录及其内部文件及文件夹</li></ul></li><li>eg: <code>rm -f text.txt</code><ul><li>删除该文件且不提示</li></ul></li></ul></li><li><p>cp(copy): 复制</p><ul><li>选项 <ul><li>-a: 相当于 -dr --preserve=all 的组合，表示来源文件为链接文件时，复制链接文件属性；递归复制；复制所有的属性和文件本身</li><li>-d: 表示来源文件为链接文件时，复制链接文件属性而非文件本身(不用该选项会造成将文件本身复制过来)</li><li>-i: 存在相同的目标文件时，询问是否覆盖（很多发行版已经默认加上）</li><li>-p(--preserve): 将文件和文件属性同时复制（默认为复制文件，属性为默认属性）</li><li>-r(recursion): 递归复制，通常用作复制目录</li><li>-u(update): 仅仅在源文件和目标文件不同时（或目标文件不存在时）复制</li><li>-l(hard link): 建立硬链接</li><li>-s(soft link): 建立符号链接（快捷方式）</li></ul></li><li>eg: <code>cp ~/.bashrc ~/.bash_history /tmp</code><ul><li>可同时复制多个文件或文件夹到某一个路径下</li></ul></li></ul></li><li><p>rm(remove): 删除</p><ul><li>选项 <ul><li>-f: 强制，不提醒删除</li><li>-r: 递归删除</li><li>-i: 删除前确定（很多的发行版已经默认加上）</li></ul></li><li>eg: <code>rm -rf nobydir</code><ul><li>不提醒删除文件夹及其子文件夹和文件</li></ul></li></ul></li><li><p>mv(move): 移动/重命名</p><ul><li>选项 <ul><li>-f: 强制，不提醒移动</li><li>-i: 若存在目标文件，会询问是否覆盖</li><li>-u(update): 只有源文件比目标文件新（或目标文件不存在时）才覆盖</li></ul></li><li>eg: <code>mv nobydir nobydir2</code><ul><li>将本文件夹下的nobydir更名为nobydir2</li></ul></li><li>eg: <code>mv testdir testdir2 /tmp</code><ul><li>将多个文件夹/文件移动至某个文件夹下</li></ul></li></ul></li><li><p>cat(concatenate)(连续): 文件的查看，输出后回到命令提示符（一次性输出结果）</p><ul><li>选项 <ul><li>-A: 参看包括特殊符号在内的文本</li><li>-n: 添加行号（空白显示行号）</li><li>-b: 添加行号（空白不显示行号）</li></ul></li></ul></li><li><p>more: 文件的查看，进入软件的环境（分页显示）</p><ul><li>q: 退出软件</li><li>f(forword)/space: 向下翻页</li><li>b(backword): 向上翻页</li><li>enter: 向下翻行</li><li>/字符串: 向下查找内容</li><li>:f: 显示文件名及当前行数</li></ul></li><li><p>less: 文件的查看，进入软件的环境（分页显示）</p><ul><li>q: 退出软件</li><li>pagedown: 向下翻页</li><li>pageup: 向上翻页</li><li>/字符串: 向下查找内容</li><li>?字符串: 向上查找内容</li><li>n/N: 查找的内容中切换</li><li>g/G: 第一行和最后一行切换</li></ul></li><li><p>head: 文件的查看，查看前几行，输出后回到命令提示符（一次性输出结果）</p><ul><li>eg: <code>head /etc/man_db.conf</code><ul><li>查看前10行（默认为10行）</li></ul></li><li>eg: <code>head -n 5 /etc/man_db.conf</code><ul><li>查看前5行</li></ul></li></ul></li><li><p>tail: 文件的查看，查看后几行，输出后回到命令提示符（一次性输出结果）</p><ul><li>eg: <code>tail /etc/man_db.conf</code><ul><li>查看后10行（默认为10行）</li></ul></li><li>eg: <code>tail -n 5 /etc/man_db.conf</code><ul><li>查看后5行</li></ul></li><li>eg: <code>head -n 20 /etc/man_db.conf | tail -n 10</code><ul><li>显示11到20行的内容，| 表示管道命令，即为将前面的而结果交给后面执行</li></ul></li></ul></li><li><p>touch: 新建文件，修改文件的时间</p><ul><li>选项 <ul><li>-a: 仅修订 atime</li><li>-c: 仅修改 ctime</li><li>-d: 修改为指定日期</li><li>-m: 仅修改 mtime</li><li>-t: 修改为指定时间</li></ul></li></ul></li><li><p>umask: 指定目前用户在建立文件或目录时候的权限默认值</p><ul><li><p>eg: <code>umask</code></p><ul><li>权限显示，第一组是特殊权限。后三位数与一般权限有关，文件为666的互补数字，文件夹为777的互补数字。即021代表646文件权限，代表的文件夹权限为756</li></ul></li><li><p>eg: <code>umask -S</code></p><ul><li>-S 表示Symbolic，可以看到符号类型的方式显示权限</li></ul></li><li><p>eg: <code>umask 002</code></p><ul><li>将当前账号的文件权限修改为664，文件夹权限修改为775</li></ul></li></ul></li><li><p>chattr: 设置某个文件的隐藏属性</p><ul><li><p>选项</p><ul><li>i: 让文件不能修改、删除、更名等，只有root才能设置此属性</li><li>a: 让文件只能写入，只有root才能设置此属性</li></ul></li><li><p>eg: <code>chattr +i test.txt</code></p><ul><li>给 test.txt 添加 i 隐藏属性</li></ul></li><li><p>eg: <code>chattr -a test.txt</code></p><ul><li>移除 test.txt 的 a 隐藏属性</li></ul></li></ul></li><li><p>lsattr: 查看某个文件的隐藏属性</p><ul><li><p>选项</p><ul><li>-a: 将隐藏文件的属性也显示出来</li><li>-d: 如果接的是目录，仅列出目录本身的属性而非目录内的文件名</li><li>-R: 连同子目录的数据一同显示</li></ul></li><li><p>eg: <code>lsattr test.txt</code></p><ul><li>列出 test.txt 的隐藏属性</li></ul></li></ul></li><li><p>file: 判断文件格式</p><ul><li>eg: <code>file ~/.bashrc</code><ul><li>判断该文件的格式</li></ul></li></ul></li><li><p>which: 根据PATH路径搜索命令位置</p><ul><li>eg: <code>which ls</code></li><li>eg: <code>which history</code><ul><li>history 为bash内建的指令，不能在PATH中找到</li></ul></li></ul></li><li><p>whereis: 在一些特定的目录中寻找文件和文件名(不能全部找到)</p><ul><li>选项 <ul><li>-l: 可列出 whereis 会去查询的几个主要目录</li><li>-b: 只找 binary 格式的文件</li><li>-m: 只找在说明文件 manual 路径下的文件</li></ul></li></ul></li><li><p>locate: 在已建立的数据库中寻找(/var/lib/mlocate/)</p><ul><li><p>选项</p><ul><li>-i: 忽略大小写</li><li>-l: 列出指定行数，列入 -l 5</li></ul></li><li><p>eg: <code>locate -l 5 passwd</code></p></li></ul></li><li><p>find: 在磁盘中查找文件</p><ul><li><p>find [PATH] [option] [action]</p></li><li><p>选项</p><ul><li>-mtime n: 查找在距今 n 天之前的一天之内被改动的文件(-ctime 为状态改变，-atime为文件内容被读取)</li><li>-mtime +n: 查找在距今 n 天之前被改动的文件</li><li>-mtime -n: 查找在具备 n 天之后被改动的文件</li><li>-newer file: 列出比 file 还要早的文件</li><li>-user name: 列出某用户的文件</li><li>-name filename: 列出文件名为filename的文件</li></ul></li><li><p>eg: <code>find / -mtime 0</code></p><ul><li>列出根目录之前24h修改的文件</li></ul></li><li><p>eg: <code>find /etc -newer /etc/passwd</code></p><ul><li>列出/etc中比/etc/passwd 新的文件</li></ul></li><li><p>eg: <code>find /home -user noby</code></p><ul><li>列出/home中noby用户的文件</li></ul></li><li><p>eg: <code>find / -name passwd</code></p><ul><li>列出/中的名为passwd的文件</li></ul></li></ul></li><li><p>ln: 建立连接</p><ul><li><p>硬链接(Hard Link)：不能跨 filesystem，不能link目录，相同的硬链接连接同一个block，只要删除的不是最后一个连接就不会删除文件对应的block</p><ul><li><p>eg: <code>ln /etc/crontab .</code></p><ul><li>在当前目录建立同名/etc/crontab 的硬连接</li></ul></li><li><p>eg: <code>ln /etc/crontab corntab2</code></p><ul><li>在当前目录建立/etc/crontab 的硬连接corntab2</li></ul></li></ul></li><li><p>软连接(Symbolic Link)（符号链接）：只是在原文件上建立了一个指向原文件名的文件</p><ul><li>eg: <code>ln -s /etc/crontab crontab_link</code><ul><li>建立一个软连接在当前目录</li></ul></li></ul></li></ul></li><li><p>压缩文件的扩展名</p><ul><li>.Z: compress程序压缩的文件：</li><li>.zip: zip程序压缩的文件</li><li>.gz: gzip程序压缩的文件</li><li>.bz2: bzip2程序压缩的文件</li><li>.xz: xz程序压缩的文件</li><li>.tar: tar程序打包的数据，并没有压缩过</li><li>.tar.gz: tar程序打包的文件，其中并且经过gzip的压缩（使用最多）</li><li>.tar.bz2: tar程序打包的文件，其中并且经过bzip2的压缩</li><li>.tar.xz: tar程序打包的文件，其中并且经过xz的压缩</li></ul></li><li><p>gzip: 可以用于.Z .zip .gz 的压缩、解压指令</p><ul><li><p>选项</p><ul><li>-c: 将压缩的数据输出到屏幕上，可透过数据流冲导向来处理</li><li>-c: 解压的参数</li><li>-t: 可以用来检验一个压缩文件的一致性</li><li>-v: 可以显示出原文件/压缩文件的压缩比等信息</li><li>-#: <code>#</code>代表数字，代表选择压缩的等级，-1最快，压缩比最差，-9最慢，压缩比最好</li></ul></li><li><p>eg: <code>gzip -v services</code></p><ul><li>压缩services并显示信息，压缩后的原文件将不复存在</li></ul></li><li><p>eg: <code>gzip -d services.gz</code></p><ul><li>解压services，解压后的原文件将不复存在</li></ul></li><li><p>eg: <code>gzip -9 -c services &gt; services.gz</code></p><ul><li>使用最佳压缩比压缩，保留原文件</li></ul></li></ul></li><li><p>zcat/zmore/zless: 在不解压的情况下，读取文本压缩文件的内容，可以用于.Z .zip .gz 的压缩文件</p><ul><li>eg: zcat services.gz <ul><li>在不解压的情况下，读取文本压缩文件的内容</li></ul></li></ul></li><li><p>bzip2: 取代gzip并提供更好的压缩比</p><ul><li><p>选项</p><ul><li>-c: 将压缩的过程产生的数据输出到屏幕上！</li><li>d: 解压缩的参数</li><li>-k: 保留源文件，而不会删除原始的文件喔！</li><li>-z; 压缩的参数（默认值，可以不加）</li><li>-v: 可以显示出原文件/压缩文件案的压缩比等信息：</li><li>-#: 与gzip同样的，都是在计算压缩比的参数，-9最佳，-1最快！</li></ul></li><li><p>eg: <code>bizp2 -v services</code></p><ul><li>压缩，并取代原文件</li></ul></li><li><p>eg: <code>bzip2 -d services.bz2</code></p><ul><li>解压缩</li></ul></li><li><p>eg: <code>bzip2 -9 -c services &gt; services.bz2</code></p><ul><li>最佳压缩比，保留原文件</li></ul></li></ul></li><li><p>bzcat/bzmore/bzless/bzgrep: 在不解压的情况下，读取文本压缩文件的内容</p><ul><li>eg: <code>bzcat services.bz2</code><ul><li>在不解压的情况下，读取文本压缩文件的内容</li></ul></li></ul></li><li><p>xz: 压缩比更高的压缩、解压软件</p><ul><li><p>选项</p><ul><li>-d: 解压</li><li>-r: 测试压缩文件的完整性</li><li>-l: 列出压缩文件的相关信息</li><li>-k: 保留原本的文件不删除</li><li>-c: 将数据由屏幕上输出</li><li>-#: 调整压缩比</li></ul></li><li><p>eg: <code>xz -v services</code></p><ul><li>压缩</li></ul></li><li><p>eg: <code>xz -l services.xz</code></p><ul><li>列出压缩文件的信息</li></ul></li><li><p>eg: <code>xz -d services.xz</code></p><ul><li>解压缩</li></ul></li><li><p>eg: <code>xz -k services</code></p><ul><li>保留原文件压缩</li></ul></li></ul></li><li><p>tar: 打包、压缩指令</p><ul><li><p>选项</p><ul><li>-c: 建立打包文件，可搭配-v来察看过程中被打包的档名(filename)</li><li>-t: 察看打包文件的内容含有哪些档名，重点在察看文件名就是了；</li><li>-x: 解打包或解压缩的功能，可以搭配-C(大写)在特定目录解开。特别留意的是，-c,-t,-x不可同时出现在一串指令列中。</li><li>-z: 透过gzip的支持进行压缩/解压缩：此时档名最好为.tar.gz</li><li>-j: 透过bzip2的支持进行压缩/解压缩：此时档名最好为.tar.bz2</li><li>-J: 透过xz的支持进行压缩/解压缩：此时档名最好为.tar.xz。特别留意，-z,-j,-J不可以同时出现在一串指令列中</li><li>-v: 在压缩/解压缩的过程中，将正在处理的文件名显示出来！</li><li>-f filename: -f后面要立刻接要被处理的档名！建议-f单独写一个选项啰！（比较不会忘记）</li><li>-C 目录: 这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</li><li>-p(小写): 表示保留备份数据的原本权限与属性，常用于备份</li><li>-P(大写): 表示保留绝对路径，允许备份数据中含有根目录存在之意</li></ul></li><li><p>eg: <code>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录</code></p><ul><li>压缩，-z(.gz),-j(.bz2),-J(.xz)表示解压和压缩的方式，c表示打包，-f表示执行的文件，v表示的处理的过程</li></ul></li><li><p>eg: <code>tar -jtv -f filename.tar.bz2</code></p><ul><li>查询，-t表示查看</li></ul></li><li><p>eg: <code>tar -jxv -f filename.tar.bz2 -C 要解压到的目录</code></p><ul><li>解压，-x表示解压，-C表示解压的目录</li></ul></li></ul></li><li><p>alias: bash中的命令别名，当前bash生效</p><ul><li><p>编辑~/.bashrc: 该账户alias永久有效</p><ul><li>eg: <code>source ~/.bashrc</code><ul><li>刷新文件</li></ul></li></ul></li><li><p>编辑/etc/bashrc: 所有用户alias永久生效</p><ul><li>eg: <code>source /etc/bashrc</code></li></ul></li><li><p>eg: <code>alias</code></p><ul><li>查看bash中的别名，其中有一部分是发行版的预设</li></ul></li><li><p>eg: <code>alias la=&#39;ll -al --color=auto&#39;</code></p><ul><li>添加命令别名</li></ul></li><li><p>eg: <code>unalias la</code></p><ul><li>移除命令别名</li></ul></li></ul></li><li><p>source: 将配置文件的内容读进目前的shell中，source命令通常用于保留、更改当前shell中的环境变量。</p><ul><li>eg: <code>source ~/.bashrc</code><ul><li>将更改后的~/.bashrc更新到shell中（否则需要重启）</li></ul></li></ul></li><li><p>history: 查看历史命令 !数字 执行历史命令</p><ul><li><p>eg: <code>history</code></p><ul><li>查看当前的历史命令，输入 !数字 执行命令</li></ul></li><li><p>eg: <code>!number</code></p><ul><li>执行第number命令</li></ul></li><li><p>eg: <code>!ls</code></p><ul><li>执行最近的 ls 开头的命令</li></ul></li></ul></li><li><p>test: 查看指定目录下的文件或文件夹是否存在，判断条件，可用 [] 代替</p><ul><li><p>-e: 是否存在</p></li><li><p>-f: 该名的文件是否存在</p></li><li><p>-d: 该名的目录是否存在</p></li><li><p>-r: 该名文件是否存在并且具有可读性</p></li><li><p>-w: 该名文件是否存在并且具有可写性</p></li><li><p>-e: 该名文件是否存在并且具有可执行性</p></li><li><p>-a: and</p></li><li><p>-o: or</p></li><li><p>!: 非</p></li><li><p>eg: <code>test -e noby;echo $?</code></p><ul><li>某任何类型的文件或文件夹是否存在</li></ul></li><li><p>eg: <code>test -f text.txt;echo $?</code></p><ul><li>文件是否存在</li></ul></li><li><p>eg: <code>test -d nobydir;echo $?</code></p><ul><li>文件夹是否存在</li></ul></li></ul></li></ul><h3 id="vim文件编辑器" tabindex="-1"><a class="header-anchor" href="#vim文件编辑器" aria-hidden="true">#</a> vim文件编辑器</h3><ul><li><p>输入 vimtutor 进入 linux 自带的练习</p></li><li><p>vi和vim的区别</p><ul><li>vi主要用于文本编译</li><li>vim主要用于程序编写，具有颜色提示和文本补齐，为vi的升级版，vi中的大部分内容和功能都包含</li></ul></li><li><p>vim/vi的三种模式</p><ul><li>一般模式 <ul><li>编辑模式或底行模式下，按 esc 退出到一般模式 <ul><li>常用命令 <ul><li>v: 字符选择</li><li>V: 行选择</li><li>[Ctrl] + v: 区块选择</li><li>[Ctrl] + w: 多窗口条件下，上下键窗口选择，q为删除窗口</li><li>ZZ: 改动后，保存改动离开。没保存直接离开</li><li>y数字y(数字yy)：复制行</li><li>y$：复制光标位置到行末</li><li>y^：复制光标位置到行首</li><li>yw：复制当前单词</li><li>数字p：粘贴</li><li>数字dd：删除行</li><li>d$：删除光标位置到行末</li><li>d^：删除光标位置到行首</li><li>dw：删除单词</li><li>n/N：跳转查找词</li><li>u：撤销</li><li>x：删除字符</li><li>X：退回字符</li><li>r：字符替换</li><li>R：依次替换</li><li>w：移动到下个词首</li><li>e：移动到下个词尾</li><li>b：移动到上个词首</li><li>gg：移动到文件开头</li><li>G：移动到文件结尾</li><li>数字G：移动到指定行(可通过:set nu命令打开行编号，:set nu为关闭行编号)</li></ul></li></ul></li></ul></li><li>编辑模式：行低显示insert <ul><li>i/a/o/I/A/O 进入编辑模式</li></ul></li><li>底行模式：输入:,/,?进入 <ul><li>:q!：退出不保存</li><li>:wq：退出保存</li><li>:wq!：强制退出保存只读文件</li><li>:w：保存</li><li>:w [filename]: 将当前文件另存为filename</li><li>:n1,n2 w [filename]: 将当前文件的n1到n2行另存为filename</li><li>:r [filename]: 将其他文件的数据读取到当前文件的光标处</li><li>:q：退出</li><li>:! command:占时离开vim执行command显示器结果</li><li>:/word：向下查找单词</li><li>:?word: 向上查找单词</li><li>:n/N: 多文件编辑文件跳转</li><li>:files: 多文件编辑文件列表查看</li><li>:sp [filename]: 将filename加入多窗口，不输入时为将该文件再开一个窗口</li><li>😒/老单词/新单词：本行第一个单词替换</li><li>😒/老单词/新单词/g：本行所有单词替换</li><li>:n1,n2s/老单词/新单词/g：n1到n2行所有单词替换</li><li>:%s/老单词/新单词：所有行第一个单词替换</li><li>:%s/老单词/新单词/g：所有行所有单词替换</li><li>:set all: 显示所有的环境设定</li></ul></li></ul></li><li><p>vim编辑器的环境设定</p><ul><li><p>设置配置文件</p><ul><li>本机的配置文件位于/etc/vimrc</li><li>账户的配置文件位于~/.vimrc</li></ul></li><li><p>常用的配置</p><ul><li>:set nu：显示行号 :set nonu：取消行号</li><li>:syntax on: 进行语法检验</li><li>:set hlsearch: 高亮反白</li></ul></li></ul></li></ul><h3 id="linux-shell" tabindex="-1"><a class="header-anchor" href="#linux-shell" aria-hidden="true">#</a> linux shell</h3>',16),r=l("ul",null,[l("li",null,"解释：shell 是作为用户和linux的核心(kernel)之间的交流媒介，是提供用户操作系统的一个接口。shell 可以控制其他应用程序，如ls、vim、tar等指令都是调用应用程序的过程。只要能过操作应用程序的接口都能够称为shell（壳程序），狭义的shell指的是命令行方面的软件（如bash），广义的shell则包括图形接口的软件。"),l("li",null,"bash是linux的shell之一。linux的默认shell程序是bash"),l("li",null,"使用者通过命令行或图形界面的方式和shell交流，使之控制kernel，从而kernel控制硬件做出相应的响应"),l("li",null,[i("bash配置文件的位置 ~/.bashrc，配置之后重启生效 "),l("ul",null,[l("li",null,[i("eg: "),l("code",null,'export mysrc="/usr/local/src/"'),l("ul",null,[l("li",null,"配置自定义变量")])])])]),l("li",null,[i("bash中的符号 "),l("ul",null,[l("li",null,[l("code",null,"#"),i(": 批注符号：这个最常被使用在script当中，视为说明！在后的数据均不执行")]),l("li",null,[l("code",null,"\\"),i(": 跳脱符号：将「特殊字符或通配符」还原成一般字符")]),l("li",null,[l("code",null,"|"),i(": 管线(pipe):分隔两个管线命令的界定，管线命令只可用于接收来自正确的输出，将正确的输出进一步处理，|的后面只可跟可以处理 standard input 的命令，如less,more,head,tail等，ls,cp,mv等不可接收管线命令 "),l("ul",null,[l("li",null,[i("eg: "),l("code",null,"last | grep 'root'"),l("ul",null,[l("li",null,"last输出登陆信息，找出带'root'的行，并显示出来")])]),l("li",null,[i("eg: "),l("code",null,"grep 'MANPATH' /etc/man_db.conf"),l("ul",null,[l("li",null,"输出带有MANPATH字样的行")])])])]),l("li",null,[l("code",null,";"),i(": 连续指令下达分隔符：连续性命令的界定（注意！与管线命令并不相同）")]),l("li",null,[l("code",null,"~"),i(": 用户的家目录")]),l("li",null,[l("code",null,"$"),i(": 取用变数前导符：亦即是变量之前需要加的变量取代值")]),l("li",null,[l("code",null,"&"),i(": 工作控制((job control):将指令变成背景下工作")]),l("li",null,[l("code",null,"&&"),i(": and符号，表示前者命令正确后执行后面命令，否则不执行后面命令。")]),l("li",null,[l("code",null,"||"),i(": or符号，表示前者错误时执行后面命令，否则不执行后面命令。")]),l("li",null,[l("code",null,"!"),i(": 逻辑运算意义上的「非」not的意思！")]),l("li",null,[l("code",null,"/"),i(": 目录符号：路径分隔的符号")]),l("li",null,[l("code",null,">,>>"),i(": 数据流重导向：输出导向，分别是『取代」与『累加」 "),l("ul",null,[l("li",null,[i("eg: "),l("code",null,"cat test2.txt > test.txt"),l("ul",null,[l("li",null,"将tset2.txt中的文件数据流输入到test.txt，如果不存在test.txt则创建，如果存在则覆盖原本内容")])]),l("li",null,[i("eg: "),l("code",null,"cat test2.txt >> test.txt"),l("ul",null,[l("li",null,"将tset2.txt中的文件数据流输入到test.txt，如果不存在test.txt则创建，如果存在则追加原本内容")])]),l("li",null,[i("eg: "),l("code",null,"cat test2.txt test3.txt 1> test.txt 2> test0.txt"),l("ul",null,[l("li",null,"不存在test3.txt，程序将会报错，将错误信息传递到test0.txt，正确信息传递到test.txt，1表示正确数据，2表示错误数据")])]),l("li",null,[i("eg: "),l("code",null,"cat > catfile"),l("ul",null,[l("li",null,"数据输出流导向到catfile，由于未指定导向的来源，因此由键盘输入")])])])]),l("li",null,[l("code",null,"<,<<"),i(": 数据流重导向：输入导向，将原本需要由键盘输入的内容直接由文件读取 "),l("ul",null,[l("li",null,[l("code",null,"cat > catfile < /.bashrc"),l("ul",null,[l("li",null,"数据流输出导向建立catfile，数据输出流将键盘内容输入导向/.bashrc文件输入")])])])]),l("li",null,[l("code",null,"''"),i(": 单引号，不具有变量置换的功能($变为纯文本)")]),l("li",null,[l("code",null,'""'),i(": 具有变量置换的功能！($可保留相关功能)")]),l("li",null,"``: 两个符号中间为可以先执行的指令，亦可使用${}"),l("li",null,[l("code",null,"()"),i(": 在中间为子shel‖的起始与结束")]),l("li",null,[l("code",null,"{}"),i(": 在中间为命令区块的组合！")])])]),l("li",null,[i("环境变量 "),l("ul",null,[l("li",null,"环境变量即为系统的全局变量。常用的环境变量有PATH、HOME、MAIL、SHELL，环境变量为了与自定义变量形成区别，通常是大写。当用户未指定目录的情况下直接执行某指令如 ls 会在PATH环境变量的值中寻找是否存在该指令，存在即调用对应目录下的指令（存在多个时调用第一个搜寻到的），不同用户的环境变量不相同，使用本目录下的命令的方式为 ./命令名，为了安全起见，本目录(.)不放入到$PATH中"),l("li",null,[i("eg: "),l("code",null,"echo $PATH"),l("ul",null,[l("li",null,"查看$PATH环境变量")])]),l("li",null,[i("eg: "),l("code",null,'PATH="${PATH}:/root"'),l("ul",null,[l("li",{PATH:""},[i("给环境变量"),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"P"),l("mi",null,"A"),l("mi",null,"T"),l("mi",null,"H"),l("mtext",null,"添加新的内容，将"),l("mi",{mathvariant:"normal"},"/"),l("mi",null,"r"),l("mi",null,"o"),l("mi",null,"o"),l("mi",null,"t"),l("mtext",null,"目录加入环境变量，")]),l("annotation",{encoding:"application/x-tex"},"PATH添加新的内容，将/root目录加入环境变量，")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P"),l("span",{class:"mord mathnormal"},"A"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"T"),l("span",{class:"mord mathnormal",style:{"margin-right":"0.08125em"}},"H"),l("span",{class:"mord cjk_fallback"},"添加新的内容，将"),l("span",{class:"mord"},"/"),l("span",{class:"mord mathnormal"},"roo"),l("span",{class:"mord mathnormal"},"t"),l("span",{class:"mord cjk_fallback"},"目录加入环境变量，")])])]),i("PATH等同$")])])]),l("li",null,[i("eg: "),l("code",null,"env"),l("ul",null,[l("li",null,"查看所有的环境变量")])]),l("li",null,[i("eg: "),l("code",null,"export"),l("ul",null,[l("li",null,"查看所有的环境变量")])]),l("li",null,[i("eg: "),l("code",null,"read bike"),l("ul",null,[l("li",null,"-p: 指定输入时提示的信息"),l("li",null,"-t: 指定输入的倒计时，倒计时结束即输入为空"),l("li",null,"从用户的键盘输入变量")])]),l("li",null,[i("eg: "),l("code",null,"declare -i sum=1+2"),l("ul",null,[l("li",null,"-a: 将后面的变量定义为数组"),l("li",null,"-i: 将后面的变量定义为整数"),l("li",null,"-x: 将后面的变量定义为环境变量"),l("li",null,"+x: 将后面的环境变量定义为自定义变量"),l("li",null,"-r: 将后面的变量定义为只读")])]),l("li",null,[i("将变量定义为integer类型，如果直接输入 "),l("code",null,"sum=1+2"),i(" 将会得到'1+2'字符串，变量的类型在不指定的情况下默认为字符串，bash环境中的数值运算只能保留整数")])])]),l("li",null,[i("变量规则 "),l("ul",null,[l("li",null,[l("p",null,[i("变量一般为 "),l("code",null,"${变量}"),i(" ，或 "),l("code",null,"$变量"),i(" ，在定义时，可直接使用 变量")]),l("ul",null,[l("li",null,[l("p",null,[i("eg: "),l("code",null,"echo $myname")]),l("ul",null,[l("li",null,"输出自定义变量$myname，未定义为空")])]),l("li",null,[l("p",null,[i("eg: "),l("code",null,"myname=noby")]),l("ul",null,[l("li",null,"将自定义变量赋值")])]),l("li",null,[l("p",null,[i("eg: "),l("code",null,"echo ${myname}")]),l("ul",null,[l("li",null,"输出自定义变量$myname，noby")])])])]),l("li",null,[l("p",null,"变量与变量内容之间用一个=表示，=两边不能存在空格。变量名以数字和英文字母组成，但不能以数字开头")]),l("li",null,[l("p",null,`变量内容可以用" "或' '，" "可以解析变量保有原来的特征，' '只能解析成为纯文本`),l("ul",null,[l("li",null,[l("p",null,[i("eg: "),l("code",null,'var="lang is $LANG"; echo $var')]),l("ul",null,[l("li",null,"结果为 lang is zh_CN.UTF-8")])]),l("li",null,[l("p",null,[i("eg: "),l("code",null,"var='lang is $LANG'; echo $var")]),l("ul",null,[l("li",null,"结果为 lang is $LANG")])])])]),l("li",null,[l("p",null,"命令执行时，可用$()或``将命令嵌套至其他命令，先执行$()中的命令，再执行外面的命令"),l("ul",null,[l("li",null,[l("p",null,[i("eg: "),l("code",null,"echo $(uname -r)"),i(" 或 使用"),l("code",null,"uname -r")]),l("ul",null,[l("li",null,[i("打印系统版本信息，使用"),l("code",null,"echo uname -r"),i("错误")])])])])]),l("li",null,[l("p",null,[i("当变量需要扩充内容时，可以使用"),l("code",null,"变量=${变量}添加的内容"),i("或"),l("code",null,'变量="$变量"添加的内容')]),l("ul",null,[l("li",null,[l("p",null,[i("eg: "),l("code",null,"myname=${myname}append; echo $myname")]),l("ul",null,[l("li",null,"输出自定义变量$myname，未定义为空")])])])]),l("li",null,[l("p",null,[i("若该变量需要在其他子程序执行，则需要以export来是变量变成环境变量（当前的shell中还可以开启一个shell，使用"),l("code",null,"bash"),i("开启一个新的bash）")]),l("ul",null,[l("li",null,[l("p",null,[i("eg: "),l("code",null,"export myname")]),l("ul",null,[l("li",null,"使得普通变量变为环境变量，环境变量相对普通自定义变量，它可以存在子程序中。")])]),l("li",null,[l("p",null,[i("eg: "),l("code",null,"bash")]),l("ul",null,[l("li",null,"进入当前bash的子程序")])]),l("li",null,[l("p",null,[i("eg: "),l("code",null,"echo $myname")]),l("ul",null,[l("li",null,"在子程序中的而$myname仍然生效，如果不export，则父程序中的变量在子程序中不生效")])]),l("li",null,[l("p",null,[i("eg: "),l("code",null,"exit")]),l("ul",null,[l("li",null,"退出当前程序的子程序")])])])]),l("li",null,[l("p",null,"系统的变量通常默认为大写字符，自定义变量通常为小写"),l("ul",null,[l("li",null,[l("p",null,[i("eg: "),l("code",null,"echo $PATH")]),l("ul",null,[l("li",null,"输出环境变量")])]),l("li",null,[l("p",null,[i("eg: "),l("code",null,"echo $myname")]),l("ul",null,[l("li",null,"输出自定义变量")])])])]),l("li",null,[l("p",null,"取消变量使用unset"),l("ul",null,[l("li",null,[i("eg: "),l("code",null,"unset myname"),l("ul",null,[l("li",null,"释放变量myname")])])])])])])],-1),p=e('<h3 id="shell-script" tabindex="-1"><a class="header-anchor" href="#shell-script" aria-hidden="true">#</a> Shell Script</h3><ul><li><p>执行脚本的方法</p><ul><li>输入绝对路径，在子shell中执行</li><li>输入相对路径，在子shell中执行</li><li>将文件放入环境变量PATH某个指定的目录下，如~/bin/，直接输入文件名，在子shell中执行</li><li><code>bash 文件路径</code>，在子shell中执行</li><li><code>sh 文件路径</code>，sh为bash的符号链接（软连接），子shell中执行</li><li><code>source 文件名</code>，在本shell中执行</li><li><code>. 文件名</code>，在本shell中执行</li></ul></li><li><p>脚本的开头申明</p><ul><li><p><code>#!/bin/bash</code></p><ul><li>说明脚本使用的shell</li></ul></li></ul></li><li><p>内置变量</p><ul><li>$0: 文件名及路径</li><li>$1: 第一个参数</li><li>$2: 第二个参数</li></ul></li><li><p>sh: 执行script</p><ul><li><p>选项</p><ul><li>-n: 不执行script，仅查询语法问题</li><li>-v: 执行脚本前，将脚本内容输出到屏幕上</li><li>-x: 将使用到的script内容输出到屏幕上</li></ul></li></ul></li></ul><h3 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理" aria-hidden="true">#</a> 进程管理</h3><ul><li>程序(program)：通常为binary program，放置在储存媒体中（如硬盘、光盘、软盘、磁带等），为实体文 件的型态存在</li><li>进程(process)：程序被触发后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载内存中，操作系统并给予这个内存内的单元一个标识符(PID)，可以说，进程就是一个正在运作中的程序。</li><li>子进程：进入linux系统后，会取得一个bash的shell，然后，我们用这个bash提供的接口去执行另一个指令，例如usr/bin/passwd或者是touch等等，那些另外执行的指令也会被触发成为PID，那个后来执行指令才产生的PID就是子进程了，而在我们原本的bash环境下，就称为父进程了。子进程的权限来自父进程。 <ul><li>eg: <code>bash</code><ul><li>eg: <code>ps -l</code><ul><li>PPID为父进程，PID为该进程，可以看到后开的bash的父进程为初始的bash</li></ul></li></ul></li><li>ps(Process Status): 查看进程 <ul><li>选项 <ul><li>-l: 查阅当前用户开启的进程 <ul><li>F：进程的旗标，4为root，1为仅有复制，没有实际执行</li><li>S：代表状态 <ul><li>R：正在运行</li><li>S：睡眠状态</li><li>D：不可唤醒的睡眠状态</li><li>T：暂停状态</li><li>Z：僵尸状态，进程卡死</li></ul></li><li>C：cpu的占用率</li></ul></li></ul></li><li>eg: <code>ps -l</code><ul><li>查看当前用户开启的进程</li></ul></li><li>eg: <code>ps -ef | grep redis</code><ul><li>查看redis有关的进程</li></ul></li></ul></li><li>kill: 终止进程 <ul><li>eg: <code>kill PID</code><ul><li>终止进程PID</li></ul></li></ul></li></ul></li></ul><h4 id="工作管理" tabindex="-1"><a class="header-anchor" href="#工作管理" aria-hidden="true">#</a> 工作管理</h4><ul><li>可以再一个bash中运行多个进程，这些进程都是该bash的子进程 <ul><li>前景：在可以出现提示字符让你操作的环境就称为前景(foreground)</li><li>背景：非前景的其他进程就为背景(background)。需要与其他使用者互动的进程不能放入背景（vim）。背景也不可以使用ctrl+C终止 <ul><li>背景可以设置为暂停和运作 <ul><li>ctrl+z: 将当前进程放置背景并暂停</li></ul></li><li>eg: <code>tar -zpcf /tmp/etc.tar.gz /etc &amp;</code><ul><li>让打包压缩命令在背景运行</li></ul></li><li>jobs: 观察背景的进程，+表示最后一个放入背景的进程，-表示倒数第二个 <ul><li>选项 <ul><li>-l: 列出PID</li><li>-r: 仅列出正在运行的背景进程</li><li>-s: 仅列出暂停的背景进程</li></ul></li><li>eg: <code>jobs </code><ul><li>查看背景正在运行的进程</li></ul></li></ul></li><li>fg: 将背景中进程放入前景工作 <ul><li>eg: <code>fg</code><ul><li>取出最后一个放入背景的进程（带+号的）</li></ul></li><li>eg: <code>fg %2</code><ul><li>取出工作号为2的进程</li></ul></li><li>eg: <code>fg -</code><ul><li>取出倒数第二个进程（带-号的）</li></ul></li></ul></li><li>bg: 让背景暂停的进程运行 <ul><li>eg: <code>bg %3</code><ul><li>当工作号为3的进程继续运行</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="服务管理" tabindex="-1"><a class="header-anchor" href="#服务管理" aria-hidden="true">#</a> 服务管理</h3><ul><li><p>服务（service/daemon/常驻进程/服务）：常驻在内存中一直执行的进程，linux中服务的文件名通常以d结尾</p><ul><li>systemctl: 服务相关设置 <ul><li>status: 查看服务状态 <ul><li>eg: <code>systemctl status mysqld</code></li></ul></li><li>enable: 设置服务开机自启 <ul><li>eg: <code>systemctl enable mysqld</code></li></ul></li><li>list-unit-files: 查看所有服务列表 <ul><li>eg: <code>systemctl list-unit-files | grep enabled</code>: 查看自启服务</li></ul></li><li>disable: 取消开机自启</li><li>start: 开启服务</li><li>stop: 关闭服务</li><li>restart: 重启服务</li><li>is-active: 是否正在运行中</li><li>is-enable: 是否开机自启</li><li>poweroff: 关机</li><li>reboot: 重启</li></ul></li></ul></li><li><p>目录</p><ul><li><p>/usr/lib/systemd/system/:</p><ul><li>使用CentOS官方提供的软件安装后，默认的启动脚本配置文件都放在这里，这里的数据尽量不要修改。要修改时，请到/etc/systemd/system底下修改较佳！</li></ul></li><li><p>/run/systemd/system/:</p><ul><li>系统执行过程中所产生的服务脚本，这些脚本的优先序要比/usr/ib/systemd/system/高！</li></ul></li><li><p>/etc/systemd/system/:</p><ul><li>管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比run/systemd/system/高喔！</li></ul></li><li><p>/etc/sysconfig/*:</p><ul><li>几乎所有的服务都会将初始化的一些选项设定写入到这个目录下，举例来说，mandb所要更新的man page索引中，需要加入的参数就写入到此目录下的man-db当中喔！而网络的设定则写在 /etc/sysconfig/network-scripts/这个目录内。所以，这个目录内的文件也是挺重要的；</li></ul></li><li><p>/var/lib/:</p><ul><li>些会产生数据的服务都会将他的数据写入到var/lib/目录中。举例来说，数据库管理系统Mariadb的数据库默认就是写入var/lib/mysql/这个目录下啦！</li></ul></li><li><p>/run/:</p><ul><li>放置了好多daemon的暂存档，包括lock file以及PID file等等。</li></ul></li></ul></li></ul><h3 id="文件及文件夹的权限" tabindex="-1"><a class="header-anchor" href="#文件及文件夹的权限" aria-hidden="true">#</a> 文件及文件夹的权限</h3>',9),m=e("<li><p>权限rwx</p><ul><li>文件 <ul><li>r 可读</li><li>w 可写</li><li>x 可执行</li></ul></li><li>文件夹 <ul><li>r 可列出该文件夹下的文件名（可列出但不代表可进入）(可在其他目录列出该目录的文件列表名）</li><li>w 可移动、复制、新建、删除、重复名，文件、文件夹</li><li>x 拥有进入该文件夹的权限（可进入不代表可列出文件列表）</li></ul></li></ul></li>",1),h=l("p",null,"查看文件信息",-1),g=l("p",null,"ls -al",-1),b={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},v=e("<li><ul><li></li></ul><ul><li>当该位置为-时为文件，为d时为文件夹，为l时为符号链接，b表示可供存储的设备，c表示装置文件里面的串行端口设备，如键盘。</li></ul></li><li>rwx r-x r-x <ul><li>rwx <ul><li>文件所有者 可读 可写 可执行(二进制为111，十进制为7)，当为文件夹时，文件夹的所有文件权限都等同该文件夹描述的权限</li></ul></li><li>第一个r-x <ul><li>文件所属群组 可读 不可写 可执行(二进制为101，十进制为5)</li></ul></li><li>第二个r-x <ul><li>其他成员 可读 不可写 可执行(二进制为101，十进制为5)</li></ul></li></ul></li><li>1 <ul><li>硬连接连接数，表示有多少文件名连接到这个inode</li></ul></li><li>第一个root <ul><li>文件拥有者</li></ul></li><li>第二个root <ul><li>文件所属群组</li></ul></li><li>31 <ul><li>文件的大小(Bytes)</li></ul></li><li>7月 27 2022 <ul><li>最后的修改时间</li></ul></li>",7),f={href:"http://hello.sh",target:"_blank",rel:"noopener noreferrer"},x=l("ul",null,[l("li",null,"文件名（以.开头的文件或文件夹为隐藏）")],-1),y=e("<li><p>修改文件权限</p><ul><li>eg: <code>chmod u=rwx,g=rx,o=rx hello.sh</code><ul><li>修改所有者、所属群组、其他用户的读、写、执行的权限</li></ul></li><li>eg: <code>chmod u+r,g-w,o+x hello.sh</code><ul><li>表示所有者添加读属性，所属群组移除写权限，其他用户添加执行权限，可用a表示所有者、所属群组和其他用户</li></ul></li><li>eg: <code>chmod 755 hello.sh</code><ul><li>使用10进制表示</li></ul></li><li>eg: <code>chmod -R 755 hello</code><ul><li>若hello为目录，-R表示递归，作用于该文件夹下的所有的文件</li></ul></li></ul></li><li><p>修改所属用户与组</p><ul><li>eg: <code>chown noby:root hello.sh </code><ul><li>将文件修改为noby为所有者，root为所属群组</li></ul></li><li>eg: <code>chown -R noby hello</code><ul><li>直接修改所有者，若hello为目录，可使用-R递归表示修改所有子文件和文件夹</li></ul></li><li>eg: <code>chown :users hello.sh</code><ul><li>直接修改所属组</li></ul></li></ul></li>",2),k=e(`<h3 id="用户管理" tabindex="-1"><a class="header-anchor" href="#用户管理" aria-hidden="true">#</a> 用户管理</h3><ul><li>账户信息存在于 /etc/passwd 当中，账户的密码存在于 /etc/shadow ，群组信息存在于 /etc/group 当中，群组的密码存在于 /etc/gshadow 当中 <ul><li><p>eg: <code>grep noby /etc/passwd /etc/shadow /etc/group /etc/gshadow</code></p><ul><li>查看以下文件noby相关的行</li></ul></li><li><p>eg: <code>head -n 1 /etc/passwd</code></p><ul><li><code>root:x:0:0:root:/root:/bin/bash</code><ul><li>root 为用户名</li><li>x 为密码，为加密内容，存在于 /etc/shadow 中</li><li>0 为UID，用户ID</li><li>0 为GID，群组ID（初始群组）</li><li>root 为该账号说明</li><li>/root 为家目录</li><li>/bin/bash 为shell目录</li></ul></li></ul></li><li><p>eg: <code>head -n 1 /etc/group</code></p><ul><li><code>root:x:0:</code><ul><li>root 表示群组名称</li><li>x 表示群组密码</li><li>0 表示GID</li><li>最后表示其他位于该群组的用户，因为root为初始群组，所以省略。若noby是除root以外的其他用户（有效群组），则会显示<code>root:x:0:noby</code></li></ul></li></ul></li><li><p>eg: <code>cat /etc/shadow | grep user1</code></p></li></ul></li><li>id: 查看系统用户及群组 <ul><li>eg: <code>id noby</code><ul><li>查看noby的账户信息及群组</li></ul></li></ul></li><li>group: 查看用户的群组 <ul><li><p>eg: <code>groups</code></p><ul><li>查看当前登陆用户的群组，第一个为初始群组</li></ul></li><li><p>eg: <code>touch test.txt</code></p><ul><li>建立的文件的群组权限默认为初始群组</li></ul></li></ul></li><li>newgrp: 设置初始群组 <ul><li>eg: <code>newgrp users</code><ul><li>将users设置为初始群组，其他的群组为有效群组</li></ul></li></ul></li><li>useradd: 建立新账号 <ul><li>eg: <code>useradd noby</code><ul><li>建立账号noby，一般默认带有-m，表示建立家目录</li></ul></li></ul></li><li>userdel: 删除账号 <ul><li><p>eg: <code>userdel noby</code></p><ul><li>删除账号noby</li></ul></li><li><p>eg: <code>userdel -r noby</code></p><ul><li>删除账号noby，和其家目录</li></ul></li></ul></li><li>passwd: 设置密码 <ul><li><p>eg: <code>passwd noby</code></p><ul><li>设置noby的密码，root具有修改其他账户密码的权限，且可以设置过简单的密码</li></ul></li><li><p>eg: <code>passwd</code></p><ul><li>设置root的密码</li></ul></li></ul></li><li>su: 用户的切换，用户切换时，会在当前的shell中开启另一个子shell，可以使用exit退出当前的子shell（或ctrl+d） <ul><li>eg: <code>su</code><ul><li>切换到root用户，以non-login shell的方式</li></ul></li><li>eg: <code>su noby</code><ul><li>切换到noby，以non-login shell的方式 <ul><li>eg: <code>env | grep PATH</code><ul><li><code>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/src/java/jdk1.8.0_221/bin:/root/bin</code>该种方式切换后的环境变量仍然是之前的登陆用户的（root），并没有随之修改</li></ul></li></ul></li></ul></li><li>eg: <code>su -</code><ul><li>以login shell的方式切换到root</li></ul></li><li>eg: <code>su - noby</code><ul><li>以login shell的方式切换到noby <ul><li>eg: <code>env | grep PATH</code><ul><li><code>PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/src/java/jdk1.8.0_221/bin:/home/noby/.local/bin:/home/noby/bin</code>环境变量随之修改</li></ul></li></ul></li></ul></li></ul></li><li>sudo: 使当前用户以其他用户的权限执行命令，其他用户执行root权限需在 /etc/sudoers 规范 <ul><li><p>选项</p><ul><li>-u: 指定切换的用户</li><li>-b: 放到背景中执行</li></ul></li><li><p>eg: <code>sudo -u noby touch nobyfile</code></p><ul><li>root用户以noby的身份执行命令，建立的文件的所有者为noby</li></ul></li><li><p>eg: <code>sudo touch nobyfile</code></p><ul><li>其他用户以root的身份执行命令</li></ul></li></ul></li><li>visudo: 以vi编辑sudo文件，使某个账号具有以root的身份执行命令的权限 <ul><li>eg: <code>visudo</code><ul><li>eg: <code>noby ALL=(ALL) ALL</code><ul><li>root下面添加noby，使noby具有利用sudo执行root的所有权限(100行)</li></ul></li><li>eg: <code>user1 ALL =(root) /usr/bin/passwd</code><ul><li>使user1具有利用sudo执行root的passwd命令的权限</li></ul></li></ul></li></ul></li></ul><h3 id="软件的安装" tabindex="-1"><a class="header-anchor" href="#软件的安装" aria-hidden="true">#</a> 软件的安装</h3><h4 id="tarball-压缩文件" tabindex="-1"><a class="header-anchor" href="#tarball-压缩文件" aria-hidden="true">#</a> tarball（压缩文件）</h4><ul><li><p>源代码安装通过编译源代码得到软件包。优点是可以自定制软件包，缺点是比较复杂。使用打包文件安装的软件源码存放在：/usr/local/src/，安装的位置默认放在：/usr/local/（通常自定义为/usr/local/软件目录）</p></li><li><p>C语言编译运行的过程</p><ul><li><p>编写源程序</p><ul><li><p>子程序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token punctuation">[</span>root@centos7 tmp<span class="token punctuation">]</span><span class="token comment"># cat tips.c</span>
  <span class="token comment">#include &lt;stdio.h&gt;</span>
  int tips<span class="token punctuation">(</span>void<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
  		printf<span class="token punctuation">(</span><span class="token string">&quot;该软件的功能是计算90度的正弦值:<span class="token entity" title="\\n">\\n</span>&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>主程序，加入其他子程序，加入其他库文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token punctuation">[</span>root@centos7 tmp<span class="token punctuation">]</span><span class="token comment"># cat sin.c</span>
  <span class="token comment">#include &lt;stdio.h&gt;</span>
  <span class="token comment">#include &lt;math.h&gt;</span>
  int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
          float value<span class="token punctuation">;</span>
          value <span class="token operator">=</span> sin<span class="token punctuation">(</span><span class="token number">3.14</span> / <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          tips<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          printf<span class="token punctuation">(</span><span class="token string">&quot;sin(3.14 / 2)=%f<span class="token entity" title="\\n">\\n</span>&quot;</span>,value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>将源程序编译为目标文件 *.o</p><ul><li><code>gcc -c sin.c tips.c</code></li></ul></li><li><p>将多个目标文件、外部库文件（位于 /lib 和 /linb64 中）链接为二进制可执行文件 sin</p><ul><li><code>gcc -o sin sin.o tips.o</code></li></ul></li></ul></li><li><p>使用make命令和makefile文件简化编译和链接过程</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token punctuation">[</span>root@centos7 tmp<span class="token punctuation">]</span><span class="token comment"># cat makefile</span>
  main: sin.o tips.o
          gcc <span class="token parameter variable">-o</span> sin sin.o tips.o
  clean:
          <span class="token function">rm</span> <span class="token parameter variable">-f</span> sin sin.o tips.o
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>eg: <code>make</code></p><ul><li>执行 main</li></ul></li><li><p>eg: <code>make main</code></p><ul><li>执行 main</li></ul></li><li><p>eg: <code>make clean</code></p><ul><li>执行 clean</li></ul></li></ul></li><li><p>安装的步骤</p><ul><li>下载：将Tarball（tar的打包文件）由厂商的网页下载到/usr/local/src目录；</li><li>解压：将Tarball解开，产生很多的源代码文件、INSTALL/README的安装步骤文件以及侦测程序文件configure/config；</li><li>建立makefile：通过config/configure自动侦测程序，建立makefile文件。 <ul><li>通过<code>./configure</code>生成的makefile默认的安装位置为 /usr/local 。 <ul><li>该目录方便命令的使用。（/usr/local/bin已经包含在PATH中）</li><li>该目录方便man page的搜索</li></ul></li><li>通过<code>./configure --prefix=/usr/local/软件名目录</code>可指定安装位置生成makefile <ul><li>该目录更加方便软件的升级和卸载，但/usr/local/软件名目录/bin不包含在PATH中，不方便命令的下达</li></ul></li></ul></li><li>编译：通过<code>make main</code>或<code>make</code>指令执行makefile中的编译和链接 <ul><li>以gcc进行原始码的编译（会产生目标文件object files):</li><li>以gcc进行函式库、主、子程序的链接，以形成主要的binary file;</li></ul></li><li>安装：由于产生的可执行文件仍然在当前目录下，需要通过<code>make install</code>将上述的binary file以及相关的配置文件安装至自己的主机上面。</li></ul></li><li><p>卸载的步骤：</p><ul><li>源码目录执行 <code>make uninstall</code></li><li>删除相应的安装目录</li></ul></li></ul><h4 id="rpm和yum" tabindex="-1"><a class="header-anchor" href="#rpm和yum" aria-hidden="true">#</a> RPM和yum</h4><ul><li><p>RPM(RedHat Package Manager)：是以一种数据库记录的方式来将你所需要的软件安装到你的Linux系统的一套管理机制。由于己经编译完成并且打包完毕，所以软件传输与安装上很方便（不需要再重新编译）。由于安装时软件的信息都已经记录RPM数据库上，很方便查询、升级与反安装。</p></li><li><p>yum：是一个专门为了解决包依赖关系而存在的软件包管理器（即软件B的使用必须依赖软件A，其实所有的软件管理几乎都有这方面的情况存在），他的使用依赖底层的RPM，相比较RPM可以自动处理个软件的依赖关系</p><ul><li>当客户端有软件安装的需求时，客户端主机会主动的向网络上面的yum服务器的软件库网址下载清单列表，然后透过列表列表的数据与本机RPM数据库(/var/lib/rpm/)己存在的软件数据相比较，就能使用RPM一口气在线下载并安装所有需要的具有相依属性的软件了。</li></ul></li></ul><table><thead><tr><th style="text-align:left;"><strong>RPM</strong> 包<strong>默认安装</strong>路径</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;">/etc/</td><td style="text-align:left;">配置文件安装目录，如/etc/my.cfg</td></tr><tr><td style="text-align:left;">/usr/bin/</td><td style="text-align:left;">可执行的命令安装目录</td></tr><tr><td style="text-align:left;">/usr/lib/</td><td style="text-align:left;">程序所使用的函数库保存位置</td></tr><tr><td style="text-align:left;">/usr/share/doc/</td><td style="text-align:left;">基本的软件使用手册保存位置</td></tr></tbody></table><h5 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h5><ul><li><p>rpm: rpm管理指令，可安装、升级、卸载、查询，安装可选择url和本地.rmp文件</p><ul><li>选项 <ul><li>-i: 安装，通常使用-ivh</li><li>-v: 观看更详细的安装信息画面</li><li>-h: 以安装信息列显示安装进度</li><li>--prefix: 指定安装目录</li><li>-U: 升级软件包（没安装时会安装），通常使用-Uvh</li><li>-F: 已经安装时升级软件包（没安装时不会安装）,通常使用-Fvh</li><li>-q: 仅查询，后面接的软件名称是否有安装</li><li>-qa: 列出所有的，已经安装在本机Linux系统上面的所有软件名称</li><li>-qi: 列出该软件的详细信息(information),包含开发商、版本与说明等</li><li>-gl: 列出该软件所有的文件与目录所在完整文件名(1ist)</li><li>-gc: 列出该软件的所有配置文件（找出在/tc/底下的檔名而已）</li><li>-qd: 列出该软件的所有说明文件（找出与man有关的文件而已)</li><li>-qR: 列出与该软件有关的相依软件所含的文件(Required的意思)</li><li>-qf: 由后面接的文件名，找出该文件属于哪一个已安装的软件</li><li>-V: 验证该软件的文件是否被改动过</li><li>-e: 卸载某软件</li><li>--rebuilddb: 重建rpm数据库(/var/lib/rpm/)</li><li>--nodeps: 强制执行</li></ul></li><li>eg: <code>rpm -ivh http://website.name/path/pkgname.rpm</code><ul><li>通过rpm在线安装到默认目录</li></ul></li><li>eg: <code>rpm -ivh --prefix=&#39;/usr/local/pkgname&#39; http://website.name/path/pkgname.rpm</code><ul><li>通过rpm在线安装到指定目录</li></ul></li><li>eg: <code>rpm -q logrotate</code><ul><li>是否安装该软件</li></ul></li><li>eg: <code>rpm -qa | grep docker</code><ul><li>列出所有包含docker的软件</li></ul></li><li>eg: <code>rpm -ql logrotate</code><ul><li>属于该软件所提供的所有目录与文件</li></ul></li><li>eg: <code>rpm -qi logrotate</code><ul><li>列出该软件的详细说明</li></ul></li><li>eg: <code>rpm -qc logrotate</code><ul><li>列出该软件的配置文件</li></ul></li><li>eg: <code>rpm -qd logrotate</code><ul><li>列出该软件的说明文档</li></ul></li><li>eg: <code>rpm -qR logrotate</code><ul><li>若要成功安装该软件，还需要什么文件</li></ul></li><li>eg: <code>rpm -qf /bin/sh</code><ul><li>该目录是由那个软件提供的</li></ul></li><li>eg: <code>rpm -V logrotate</code><ul><li>验证该软件是否被改动过</li></ul></li></ul></li><li><p>yum: yum管理指令</p><ul><li><p>选项</p><ul><li>-y: 当yum要等待用户输入时，这个选项可以自动提供yes的响应。</li><li>-installroot: 设置软件安装的路径</li><li>-list: 列出远程库的yum软件</li><li>install: 安装软件</li><li>update: 更新软件</li><li>remove: 卸载软件</li></ul></li><li><p>eg: <code>yum list | grep pam-devel</code></p><ul><li>查看远程库中与mysql有关的软件</li></ul></li><li><p>eg: <code>yum install -y pam-devel</code></p><ul><li>安装pam-devel，确认安装</li></ul></li><li><p>eg: <code>yum remove pam-devel</code></p><ul><li>卸载pam-devel</li></ul></li></ul></li></ul><h3 id="linux的文件系统" tabindex="-1"><a class="header-anchor" href="#linux的文件系统" aria-hidden="true">#</a> linux的文件系统</h3><ul><li>data block <ul><li>作用：实际记录文件内容的地方，可设置为1k、2k、4k</li></ul></li><li>inode table <ul><li>作用：记录文件的属性、权限，文件所有block对应的位置</li></ul></li><li>superblock <ul><li>作用：记录整个文件系统的地方，如block与inode的使用量、总量，block和inode的大小</li></ul></li><li>文件：一个文件占用一个inode和至少一个block，inode记录该文件的属性和权限，block记录实际内容</li><li>文件夹：一个文件夹占用一个inode和一个block，inode记录文件夹的属性和权限，block记录文件夹中存在的文件名、文件inode number列表。（因此文件夹存在r权限即使不存在x权限也可查看其中的文件名列表），文件的文件名只与目录有关。</li></ul>`,12);function w(z,_){const u=c("ExternalLinkIcon");return n(),d("div",null,[s,r,p,l("ul",null,[m,l("li",null,[h,l("ul",null,[l("li",null,[g,l("ul",null,[l("li",null,[i("-rwxr-xr-x. 1 root root 31 7月 27 2022 "),l("a",b,[i("hello.sh"),t(u)]),l("ul",null,[v,l("li",null,[l("a",f,[i("hello.sh"),t(u)]),x])])])])])])]),y]),k])}const T=o(a,[["render",w],["__file","linux.html.vue"]]);export{T as default};
