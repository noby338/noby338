import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as o,e}from"./app.759ff6f5.js";const t={},n=e('<h2 id="javase" tabindex="-1"><a class="header-anchor" href="#javase" aria-hidden="true">#</a> javase</h2><ul><li>数组b的第3个元素为b[3]，b[0]为第0个元素而非第1个元素</li><li>方法的形参个数可以和实参可以不同。例如：void fun(int... nums) fun(1,2,3,4);</li><li>java只有值传递(引用传递传递的也是值)，值传递与地址传递从根本上就是一样的</li><li>一个类可以有多个父类(爷爷)</li><li>构造方法的作用是初始化对象的属性，而不是创建对象，对象在new时创建</li><li>可变长参数的方法可以不传参数</li><li>equals方法先判断两个字符串是否相等，再判断属性值是否相等</li><li>static 可以修饰静态内部类，该类的对象是由外部类创建</li></ul><h2 id="io流" tabindex="-1"><a class="header-anchor" href="#io流" aria-hidden="true">#</a> io流</h2><ul><li>io流中没有接口，全是实例类和抽象类</li><li>PrintWriter只操作数据目的，不操作数据源</li><li>FileReader无法读取文件的字节数</li><li>Reader是抽象类，不是接口</li></ul><h2 id="spring" tabindex="-1"><a class="header-anchor" href="#spring" aria-hidden="true">#</a> Spring</h2><ol><li>简述IoC <ul><li>Inverson of Control 控制反转</li><li>对象控制权的转移，对象从new变为Spring容器创建，其目的主要是用于用于主业务的解耦。其底层实现方式有反射、xml、工厂模式。典型应用为框架的整合。</li></ul></li><li>简述AOP <ol><li>Aspect Oriented Programming 面向切面编程</li><li>将交叉业务封装成切面，织入到主业务中，其作用在使交叉业务在主业务中的复用；底层实现为动态代理，其实现有proxy和cglib；其应用有过滤器、事务处理、日志处理</li></ol></li><li>Bean的装配方式 <ol><li>默认装配方式：</li><li>动态工厂Bean：</li><li>静态工厂Bean：</li></ol></li><li>Bean的作用域 <ol><li>singlton</li><li>prototype</li><li>request</li><li>session</li><li>globalsession</li></ol></li><li>Bean的生命周期 <ol><li>构造器</li><li>属性赋值</li><li>BeanNameAware</li><li>BeanFactoryNameAware</li><li>InitallizeBean afterPropertySet</li><li>init-method</li><li>执行核心业务</li><li>destroy-method</li></ol></li><li>BeanFactory和ApplicationContext的区别 <ol><li>BeanFactory：创建Bean的时机为调用getBean()，优点为启动初始化快，不会占用太多系统资源；缺点为第一个用户的访问速度慢</li><li>Applicationcontext：创建Bean的时机为容器的启动；其缺点为启动速度慢，占用系统的资源多；优点为第一个用户访问较快；</li></ol></li><li>ID 的注入方式 <ol><li>设值注入：通过无参构造函数实例化类，通过set方法给对象设值</li><li>构造注入：通过有参构造函数实例化类</li></ol></li><li>名词解释：切面、织入、连接点、切入点、通知、顾问 <ol><li>切面：交叉业务</li><li>织入：将切面添加到主业务中的动作</li><li>连接点：接口中可以被织入的方法</li><li>织入点：被织入的连接点</li><li>通知：切入的时间点</li><li>顾问：一种通知和切入点表达式的封装</li></ol></li><li>SpringAOP 的通知有哪些类型 <ol><li>@Before 前置通知</li><li>@AfterReturning 后置通知</li><li>@Around 环绕通知</li><li>@AfterThrowing 异常通知</li><li>@After 最终通知</li></ol></li><li>事务的四大特性 <ol><li>原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。</li><li>一致性(Consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。（张三转账给李四，张三减少的金额为李四增加的金额，或张三或李四的金额都不变，这为两种一致的状态）</li><li>持久性(lsolation)：一个事务一旦提交，他对数据库中的数据影响是永久性的</li><li>隔离性(Durability)：多个用户访问数据库时，每个用户都有一个事务，他们是相互独立互不影响的</li></ol></li><li>事务的隔离级别 脏读 不可重复读 幻读 <ol><li>读未提交 Y Y Y</li><li>读已提交（） N Y Y</li><li>可重复读（MySQL的默认隔离级别） N N Y</li><li>串行化 N N N</li></ol></li><li>事务的传播机制</li><li>maven的常用命令 <ol><li>compile 编译</li><li>test 测试</li><li>package 打包</li><li>install 安装</li><li>deploy 部署</li></ol></li></ol><h2 id="springmvc" tabindex="-1"><a class="header-anchor" href="#springmvc" aria-hidden="true">#</a> SpringMVC</h2><ol><li>Proxy 和 cglib 动态代理的区别 <ol><li>proxy： jdk内置API，其增强的目标类必须有接口，代理对象所属的类型和目标类都是该接口的实现</li><li>cglib：第三方，其有没有接口都可以，代理类为目标类的子类</li></ol></li><li>SpringAOP事务管理器不同类型的异常有什么区别 <ol><li>非受查异常：回滚</li><li>受查异常：提交，配置rollback属性，指定特定异常回滚，rollback=Exception.class</li></ol></li><li>SpringMVC 的执行流程 <ol><li>DispatcherServlet 中央调度器</li><li>HandlerMapping 处理器映射器：根据请求路径查找对应的处理器</li><li>HandlerAdapter 处理器适配器：提供不同接口的处理器的统一调用方式</li><li>Controller 控制器:处理请求</li><li>ViewResolver 视图解析器：解析响应给用户的视图</li><li>View 视图：浏览器最终得到的页面</li></ol></li><li>监听器有什么作用，ContextLoaderListener 有什么作用 <ol><li>监听器：监听 Servlet 的三大域属性：域属性在创建、销毁、，属性值在修改、添加、删除 添加事件处理方法，特定事件发生时对应的方法就会执行，例子：论坛查看在线用户（监听用户登录的 session）</li><li>ContxtLoaderListener：将 Spring 的 Bean 存储到 Servletcontext 中，保证 bean 值创建一次，以使用去 Servletcontext 去对应的 bean</li></ol></li><li>SpringMVC 的处理方法可以使用那些的参数和返回值 <ol><li>参数： <ol><li>HttpServeltRequst</li><li>HttpServletResponse</li><li>HttpSession</li><li>Model</li><li>自定义请求参数</li></ol></li><li>返回值 <ol><li>同步 <ol><li>ModelAndView</li><li>String</li><li>void</li></ol></li><li>异步 <ol><li>void</li><li>自定义对象</li><li>String（json数据）</li></ol></li></ol></li></ol></li><li>@RequstBody 和 @RsponseBody 的作用 <ol><li>@RequestBody：将请求中的 JSON 转成对象</li><li>@ResponseBody：将后端的数据序列化成 JOSN 注入到响应体中</li><li>底层：为注解驱动 + HttpMessageConveter(消息转换) + 序列化技术</li></ol></li><li>图片长传对表单的要求 <ol><li>使用 post 提交</li><li>添加 enctype=“mulipar/form-data”</li></ol></li><li>SpringMVC 拦截器的执行流程 <ol><li>preHandle：是否放行（true为放行），其执行的顺序为配置的先后顺序 <ol><li>所有的拦截器都放行后执行处理器方法</li></ol></li><li>postHandle：在处理器执行完之后执行，其执行的顺序和 preHandle 相反</li><li>afterCompletion：只要有一个拦截器放行，对应的这个方法会压栈，最后一定执行</li></ol></li><li>SpringBoot 如何实现简化 Spring 开发 <ol><li>约定大于配置 <ol><li>场景启动器 Starter-xxx</li><li>jar 包管理</li><li>自动配置类 xxxxAutoConfiguartion 自动创建当前场景中常用的 bean <ol><li>@SpringBootApplication <ol><li>SpringBoot 启动类的核心注解 <ol><li>@EnableAutoconfiguration 自动包扫描</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>举例说明单例模式和适配器模式在项目中的应用 <ol><li>单例模式 <ol><li>JDK <ol><li>Runtime</li></ol></li><li>JAVAWeb <ol><li>Servlet</li></ol></li><li>Spring <ol><li>bean</li></ol></li></ol></li><li>适配器模式 <ol><li>SpringMVC <ol><li>handlerAdapter</li></ol></li><li>处理器适配器：通过适配器对不同接口的处理器进行统一调用</li></ol></li></ol></li><li>下列注解的作用 <ol><li><code>@Configuration</code>：配置类，替换<code>&lt;bean&gt;</code></li><li><code>@Bean</code>：用在配置类的方法上，方法的返回值为系统创建的一个bean对象</li><li><code>@ComponentScan</code> 包扫描<code>&lt;context:componte-scan base-package=&quot;&quot;/&gt;</code></li><li><code>@PropertySource</code> 指定读取特定性的 properties 文件 <code>&lt;context-placeholder/&gt;</code></li><li><code>@ConfigurationProperties</code> XxxxProperties:+<code>@ConfigurationProperties</code>:读取配置文件中的特定前缀的属性值赋值给</li><li><code>@SpringBootApplication</code> SpringBoot启动类的核心注解 <code>@EnableAutoConfiguration</code> 自动包扫描</li></ol></li></ol>',8),r=[n];function a(c,s){return i(),o("div",null,r)}const g=l(t,[["render",a],["__file","tips.html.vue"]]);export{g as default};
